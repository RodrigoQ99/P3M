/* ===========================
 *   NUCLEO-L053R8  (EMPTY)
 *   Microondas - Proyecto con interrupciones (CMSIS, sin HAL)
 *   Funciones: teclado 4x4, LCD 16x2, 4x7 segmentos, buzzer (PA12),
 *              pausa real (no reinicia), # inicia/reanuda, * pausa/borra,
 *              presets con scroll, mm:ss, "Calentando"/"Finalizado".
 * =========================== */

#include "stm32l0xx.h"
#include "core_cm0plus.h"   // __NOP(), __WFI()
#include <stdint.h>
#include <stdbool.h>
#include <string.h>

/* ======= PIN MAP (cambia aquí si lo necesitas) ======= */
/* 7-seg (ánodo común): segmentos A..G,DP en PA1..PA8 */
#define SEG_PORT        GPIOA
#define SEG_A           (1u<<1)
#define SEG_B           (1u<<2)
#define SEG_C           (1u<<3)
#define SEG_D           (1u<<4)
#define SEG_E           (1u<<5)
#define SEG_F           (1u<<6)
#define SEG_G           (1u<<7)
#define SEG_DP          (1u<<8)
#define SEG_ALL_MASK    (SEG_A|SEG_B|SEG_C|SEG_D|SEG_E|SEG_F|SEG_G|SEG_DP)

/* 7-seg dígitos (enable activo-bajo) D1..D4 */
#define DIG_PORT        GPIOB
#define DIG1            (1u<<0)
#define DIG2            (1u<<1)
#define DIG3            (1u<<2)
#define DIG4            (1u<<10)

/* Keypad 4x4: Filas PB12..PB15 (salidas), Columnas PC6..PC9 (entradas pull-up) */
#define KROW_PORT       GPIOB
#define KCOL_PORT       GPIOC
#define KR0             (1u<<12)
#define KR1             (1u<<13)
#define KR2             (1u<<14)
#define KR3             (1u<<15)
#define KC0             (1u<<6)
#define KC1             (1u<<7)
#define KC2             (1u<<8)
#define KC3             (1u<<9)

/* LCD HD44780 4-bit: RS=PC0, E=PC1, D4..D7=PC2..PC5  */
#define LCD_PORT        GPIOC
#define LCD_RS          (1u<<0)
#define LCD_E           (1u<<1)
#define LCD_D4          (1u<<2)
#define LCD_D5          (1u<<3)
#define LCD_D6          (1u<<4)
#define LCD_D7          (1u<<5)
#define LCD_DB_MASK     (LCD_D4|LCD_D5|LCD_D6|LCD_D7)

/* LEDs temperatura (verde/amarillo/rojo) en PA9/PA10/PA11 */
#define LED_PORT        GPIOA
#define LED_G           (1u<<9)
#define LED_Y           (1u<<10)
#define LED_R           (1u<<11)

/* Buzzer (con 2N2222) en PA12, activo-alto */
#define BUZ_PORT        GPIOA
#define BUZ_PIN         (1u<<12)

/* ======= Utilidades GPIO ======= */
static inline void gpio_bsrr_set(GPIO_TypeDef *p, uint32_t m){ p->BSRR = m; }
static inline void gpio_bsrr_clr(GPIO_TypeDef *p, uint32_t m){ p->BSRR = (m<<16); }
static inline uint32_t gpio_idr(GPIO_TypeDef *p){ return p->IDR; }

/* ======= Estado / FSM ======= */
typedef enum { ST_IDLE, ST_SET_TIME, ST_SET_TEMP, ST_PRESETS, ST_RUNNING, ST_PAUSED, ST_DONE } fsm_state_t;
static volatile fsm_state_t g_state = ST_IDLE;

/* Tiempo */
static volatile uint32_t remaining_s = 0;   /* tiempo restante en segundos */
static volatile uint16_t tick5ms_acc = 0;   /* 200*5ms = 1s */

/* Teclado: detección single/double */
typedef struct { uint8_t pressed; uint16_t t_ms; uint8_t clicks; } keyedge_t;
static keyedge_t k_hash={0}, k_star={0};

/* Buffer edición */
static uint16_t edit_mm = 0, edit_ss = 0;    /* para A=Tiempo */
static uint8_t  edit_temp = 0;               /* para B=Temp */
static uint8_t  menu_scroll = 0;             /* scroll horizontal de cadenas */

/* Presets (segundos) */
typedef struct { const char *name; uint16_t secs; } preset_t;
static const preset_t PRESETS[4] = {
  {"Palomitas 3:00", 180},
  {"Carne 5:00"    , 300},
  {"Sopa 3:00"     , 180},
  {"Descongelar10:00", 600}
};
static uint8_t preset_idx = 0;

/* 7-seg */
static const uint8_t seg_code[10] = {
/*0*/ 0b0111111, /*1*/0b0000110, /*2*/0b1011011, /*3*/0b1001111,
/*4*/ 0b1100110, /*5*/0b1101101, /*6*/0b1111101, /*7*/0b0000111,
/*8*/ 0b1111111, /*9*/0b1101111
};
static volatile uint8_t mux_idx = 0;
static volatile uint8_t dig[4] = {0,0,0,0};
static volatile uint8_t dp_on = 0;

/* ======= Prototipos ======= */
static void clock_init(void);
static void gpio_init(void);
static void tim21_init_5ms(void);

static void lcd_init_blocking(void);
static void lcd_put4(uint8_t vh);
static void lcd_cmd(uint8_t c);
static void lcd_data(uint8_t d);
static void lcd_clear(void);
static void lcd_home(void);
static void lcd_goto(uint8_t row, uint8_t col);
static void lcd_puts(const char *s);
static void lcd_scroll_once(void);

static void sevenseg_all_off(void);
static void sevenseg_set_code(uint8_t idx, uint8_t code, bool dp);
static void sevenseg_set_from_seconds(uint32_t s);

static void keypad_scan_5ms(void);
static char  keypad_get_key(void); /* retorna '\0' si no hay */

static void leds_update_from_temp(uint8_t t);
static void buzzer_init(void);
static void buzzer_request_beeps(uint8_t n);
static void buzzer_tick_5ms(void);
static void motor_on(void);
static void motor_off(void);

static void start_cycle(uint32_t secs);
static void ui_refresh_idle(void);
static void on_key(char k);
static void handle_hash_single(void);
static void handle_hash_double(void);
static void handle_star_single(void);
static void handle_star_double(void);

/* ======= LCD (4-bit) ======= */
static void lcd_pulseE(void){ gpio_bsrr_set(LCD_PORT,LCD_E); for(volatile int i=0;i<50;i++) __NOP(); gpio_bsrr_clr(LCD_PORT,LCD_E); }
static void lcd_put4(uint8_t vh){
  uint32_t m = 0;
  if(vh&0x10) m|=LCD_D4;
  if(vh&0x20) m|=LCD_D5;
  if(vh&0x40) m|=LCD_D6;
  if(vh&0x80) m|=LCD_D7;
  /* poner líneas D4..D7 */
  LCD_PORT->BSRR = (LCD_DB_MASK<<16);  /* limpiar */
  LCD_PORT->BSRR = m;                  /* set */
  lcd_pulseE();
}
static void lcd_write8(uint8_t v, uint8_t rs){
  if(rs) gpio_bsrr_set(LCD_PORT, LCD_RS); else gpio_bsrr_clr(LCD_PORT, LCD_RS);
  lcd_put4(v & 0xF0);
  lcd_put4((v<<4)&0xF0);
  for(volatile int i=0;i<800;i++) __NOP();  // pequeña espera
}
static void lcd_cmd(uint8_t c){ lcd_write8(c,0); }
static void lcd_data(uint8_t d){ lcd_write8(d,1); }
static void lcd_clear(void){ lcd_cmd(0x01); for(volatile int i=0;i<5000;i++) __NOP(); }
static void lcd_home(void){ lcd_cmd(0x02); for(volatile int i=0;i<3000;i++) __NOP(); }
static void lcd_goto(uint8_t row, uint8_t col){
  uint8_t addr = (row==0?0x00:0x40) + col; /* col inicia en 0 */
  lcd_cmd(0x80 | addr);
}
static void lcd_puts(const char *s){ while(*s) lcd_data((uint8_t)*s++); }
static void lcd_scroll_once(void){ lcd_cmd(0x18); } /* shift display left */

static void lcd_init_blocking(void){
  /* secuencia inicial 4-bit */
  for(volatile int i=0;i<40000;i++) __NOP(); /* >15ms */
  gpio_bsrr_clr(LCD_PORT, LCD_RS|LCD_E);
  /* 8bit mode pulses */
  lcd_put4(0x30); for(volatile int i=0;i<10000;i++) __NOP();
  lcd_put4(0x30); for(volatile int i=0;i<1000;i++)  __NOP();
  lcd_put4(0x30); for(volatile int i=0;i<1000;i++)  __NOP();
  /* 4-bit */
  lcd_put4(0x20);
  lcd_cmd(0x28); /* 4-bit, 2 line */
  lcd_cmd(0x0C); /* display on, cursor off */
  lcd_cmd(0x06); /* entry mode */
  lcd_clear();
}

/* ======= 7-seg ======= */
static void sevenseg_all_off(void){
  /* apaga dígitos (activo-bajo => set a 1) y DP */
  gpio_bsrr_set(DIG_PORT, DIG1|DIG2|DIG3|DIG4);
  gpio_bsrr_set(SEG_PORT, SEG_ALL_MASK); /* segmentos en 1 (ánodo común: 1=apagado) */
}
static void sevenseg_enable_digit(uint8_t i){
  /* primero apaga todos */
  gpio_bsrr_set(DIG_PORT, DIG1|DIG2|DIG3|DIG4);
  switch(i){
    case 0: gpio_bsrr_clr(DIG_PORT, DIG1); break;
    case 1: gpio_bsrr_clr(DIG_PORT, DIG2); break;
    case 2: gpio_bsrr_clr(DIG_PORT, DIG3); break;
    default:gpio_bsrr_clr(DIG_PORT, DIG4); break;
  }
}
static void sevenseg_set_code(uint8_t idx, uint8_t code, bool dp){
  /* poner A..G según code (1=segmento encendido) => ánodo común: 0 enciende */
  /* limpia primero */
  gpio_bsrr_set(SEG_PORT, SEG_ALL_MASK);
  if(code & 0x01) gpio_bsrr_clr(SEG_PORT, SEG_A);
  if(code & 0x02) gpio_bsrr_clr(SEG_PORT, SEG_B);
  if(code & 0x04) gpio_bsrr_clr(SEG_PORT, SEG_C);
  if(code & 0x08) gpio_bsrr_clr(SEG_PORT, SEG_D);
  if(code & 0x10) gpio_bsrr_clr(SEG_PORT, SEG_E);
  if(code & 0x20) gpio_bsrr_clr(SEG_PORT, SEG_F);
  if(code & 0x40) gpio_bsrr_clr(SEG_PORT, SEG_G);
  if(dp)           gpio_bsrr_clr(SEG_PORT, SEG_DP); else gpio_bsrr_set(SEG_PORT, SEG_DP);
  sevenseg_enable_digit(idx);
}
static void sevenseg_set_from_seconds(uint32_t s){
  uint32_t mm = s/60, ss = s%60;
  dig[0] = (uint8_t)(mm/10);
  dig[1] = (uint8_t)(mm%10);
  dig[2] = (uint8_t)(ss/10);
  dig[3] = (uint8_t)(ss%10);
}

/* ======= Buzzer ======= */
static volatile uint8_t bz_state=0, left_beeps=0;
static volatile uint16_t on_ticks=0, off_ticks=0;
static void buzzer_init(void){ gpio_bsrr_clr(BUZ_PORT, BUZ_PIN); }
static void buzzer_off(void){ gpio_bsrr_clr(BUZ_PORT, BUZ_PIN); }
static void buzzer_on(void){  gpio_bsrr_set(BUZ_PORT, BUZ_PIN); }
static void buzzer_request_beeps(uint8_t n){ left_beeps=n; bz_state=0; }
static void buzzer_tick_5ms(void){
  switch(bz_state){
    case 0: if(left_beeps){ buzzer_on(); on_ticks=60; bz_state=1; } break; /* ~300ms */
    case 1: if(on_ticks==0){ buzzer_off(); off_ticks=40; bz_state=2; } else on_ticks--; break;
    case 2: if(off_ticks==0){ if(--left_beeps) bz_state=0; else bz_state=3; } else off_ticks--; break;
    default: break;
  }
}

/* ======= Motor (dummy pins, cambia si usas driver) ======= */
static void motor_on(void){ /* pon aquí tu pin real si lo agregas */ }
static void motor_off(void){}

/* ======= LEDs temp ======= */
static void leds_update_from_temp(uint8_t t){
  gpio_bsrr_clr(LED_PORT, LED_G|LED_Y|LED_R); /* apaga todo */
  if(t<=33) gpio_bsrr_set(LED_PORT, LED_G);
  else if(t<=66) gpio_bsrr_set(LED_PORT, LED_Y);
  else gpio_bsrr_set(LED_PORT, LED_R);
}

/* ======= Keypad ======= */
static const char keymap[4][4] = {
  {'1','2','3','A'},
  {'4','5','6','B'},
  {'7','8','9','C'},
  {'*','0','#','D'}
};
static volatile char last_key = 0, key_ready=0;

static void rows_drive(uint8_t r){ /* todas en 1 (pull-up), fila activa a 0 */
  gpio_bsrr_set(KROW_PORT, KR0|KR1|KR2|KR3);
  switch(r){
    case 0: gpio_bsrr_clr(KROW_PORT,KR0); break;
    case 1: gpio_bsrr_clr(KROW_PORT,KR1); break;
    case 2: gpio_bsrr_clr(KROW_PORT,KR2); break;
    default:gpio_bsrr_clr(KROW_PORT,KR3); break;
  }
}
static uint8_t read_col(void){
  uint32_t v = gpio_idr(KCOL_PORT);
  uint8_t c = 0xFF;
  if(!(v & KC0)) c=0;
  else if(!(v & KC1)) c=1;
  else if(!(v & KC2)) c=2;
  else if(!(v & KC3)) c=3;
  return c;
}
static void keypad_scan_5ms(void){
  static uint8_t r=0; static uint8_t stable=0; static char k=0;
  rows_drive(r);
  uint8_t c = read_col();
  if(c!=0xFF){
    char key = keymap[r][c];
    if(k==key){ if(stable<5) stable++; } else { k=key; stable=0; }
    if(stable==2){ last_key=key; key_ready=1; }
  }else{ k=0; stable=0; }
  r=(r+1)&3;
}
static char keypad_get_key(void){ if(key_ready){ key_ready=0; return last_key; } return 0; }

/* ======= UI helpers ======= */
static void print_mm_ss_LCD(uint32_t s){
  uint32_t mm = s/60, ss=s%60;
  char buf[6]; /* mm:ss */
  buf[0] = '0'+(mm/10)%10;
  buf[1] = '0'+(mm%10);
  buf[2] = ':';
  buf[3] = '0'+(ss/10);
  buf[4] = '0'+(ss%10);
  buf[5] = 0;
  lcd_puts(buf);
}
static void ui_refresh_idle(void){
  lcd_clear();
  lcd_goto(0,0); lcd_puts("A=Tiempo  B=Temp");
  lcd_goto(1,0); lcd_puts("C=Presets");
}

/* ======= Lógica principal ======= */
static void start_cycle(uint32_t secs){
  remaining_s = secs;
  sevenseg_set_from_seconds(remaining_s);
  tick5ms_acc = 0;
  g_state = ST_RUNNING;
  motor_on();
  lcd_clear();
  lcd_goto(0,0); lcd_puts("Calentando");
  lcd_goto(1,0); print_mm_ss_LCD(remaining_s);
}

static void handle_hash_single(void){
  if(g_state==ST_PAUSED){
    g_state=ST_RUNNING; motor_on();
    lcd_goto(0,0); lcd_puts("Calentando  ");
    return;
  }
  if(g_state==ST_SET_TIME){
    uint32_t secs = (uint32_t)edit_mm*60 + (uint32_t)edit_ss;
    if(secs>0) start_cycle(secs);
    return;
  }
  if(g_state==ST_PRESETS){
    start_cycle(PRESETS[preset_idx].secs);
    return;
  }
}
static void handle_hash_double(void){
  if(g_state==ST_RUNNING || g_state==ST_PAUSED){
    remaining_s += 10;
    sevenseg_set_from_seconds(remaining_s);
    if(g_state==ST_PAUSED){
      lcd_goto(1,0); print_mm_ss_LCD(remaining_s);
    }
  }
}
static void handle_star_single(void){
  if(g_state==ST_RUNNING){
    g_state=ST_PAUSED; motor_off();
    lcd_goto(0,0); lcd_puts("Pausa      ");
    lcd_goto(1,0); print_mm_ss_LCD(remaining_s);
    return;
  }
  if(g_state==ST_SET_TIME){
    if(edit_ss>0) edit_ss= (uint16_t)((edit_ss/10)*10);
    else if(edit_mm>0) edit_mm= (uint16_t)((edit_mm/10)*10);
    lcd_goto(1,0); lcd_puts("Tiempo "); print_mm_ss_LCD(edit_mm*60+edit_ss);
    return;
  }
  if(g_state==ST_SET_TEMP){
    edit_temp=0; lcd_goto(1,0); lcd_puts("Temp:   "); return;
  }
  lcd_goto(1,0); lcd_puts("                ");
}
static void handle_star_double(void){
  motor_off(); buzzer_off();
  remaining_s=0; tick5ms_acc=0; g_state=ST_IDLE;
  sevenseg_set_from_seconds(0);
  lcd_clear(); ui_refresh_idle();
}

/* ======= Teclas de usuario ======= */
static void on_key(char k){
  if(!k) return;
  if(k=='#'){
    if(!k_hash.pressed){ k_hash.pressed=1; k_hash.t_ms=0; k_hash.clicks++; }
    return;
  }
  if(k=='*'){
    if(!k_star.pressed){ k_star.pressed=1; k_star.t_ms=0; k_star.clicks++; }
    return;
  }

  switch(g_state){
    case ST_IDLE:
      if(k=='A'){ g_state=ST_SET_TIME; edit_mm=0; edit_ss=0; lcd_clear(); lcd_goto(0,0); lcd_puts("Tiempo"); lcd_goto(1,0); lcd_puts("00:00"); }
      else if(k=='B'){ g_state=ST_SET_TEMP; edit_temp=0; lcd_clear(); lcd_goto(0,0); lcd_puts("Temperatura"); lcd_goto(1,0); lcd_puts("Temp:   "); }
      else if(k=='C'){ g_state=ST_PRESETS; menu_scroll=0; preset_idx=0; lcd_clear(); lcd_goto(0,0); lcd_puts("Presets"); lcd_goto(1,0); lcd_puts(PRESETS[preset_idx].name); }
      break;

    case ST_SET_TIME:
      if(k>='0' && k<='9'){
        uint16_t total = (edit_mm/10)*600 + (edit_mm%10)*60 + (edit_ss/10)*10 + (edit_ss%10);
        total = (total%1000)*10 + (k-'0');
        uint16_t mm = total/60, ss = total%60;
        edit_mm = mm; edit_ss = ss;
        lcd_goto(1,0); print_mm_ss_LCD((uint32_t)mm*60+ss);
      }
      break;

    case ST_SET_TEMP:
      if(k>='0' && k<='9'){
        if(edit_temp<100) edit_temp = (uint8_t)((edit_temp*10 + (k-'0'))%101);
        lcd_goto(1,0); lcd_puts("Temp: ");
        char tbuf[4]; tbuf[0]='0'+(edit_temp/10); tbuf[1]='0'+(edit_temp%10); tbuf[2]='C'; tbuf[3]=0;
        lcd_puts(tbuf);
        leds_update_from_temp(edit_temp);
      }
      if(k=='D'){ lcd_goto(0,0); lcd_puts("Temp guardada  "); }
      break;

    case ST_PRESETS:
      if(k>='1' && k<='4'){ preset_idx = (uint8_t)(k-'1'); lcd_clear(); lcd_goto(0,0); lcd_puts(PRESETS[preset_idx].name); }
      break;

    default: break;
  }
}

/* ======= Reloj/Timer/IRQ ======= */
void TIM21_IRQHandler(void){
  if(TIM21->SR & TIM_SR_UIF){
    TIM21->SR = ~TIM_SR_UIF;

    /* multiplex 7-seg cada 5ms */
    sevenseg_set_code(mux_idx, seg_code[dig[mux_idx]], (mux_idx==1)?1:0);
    mux_idx = (uint8_t)((mux_idx+1)&3);

    /* teclado, buzzer */
    keypad_scan_5ms();
    buzzer_tick_5ms();

    /* double-click windows (~300ms) */
    if(k_hash.pressed){ k_hash.t_ms+=5; if(k_hash.t_ms>300){ if(k_hash.clicks==1) handle_hash_single(); else handle_hash_double(); k_hash.pressed=0; k_hash.clicks=0; } }
    if(k_star.pressed){ k_star.t_ms+=5; if(k_star.t_ms>300){ if(k_star.clicks==1) handle_star_single(); else handle_star_double(); k_star.pressed=0; k_star.clicks=0; } }

    /* tiempo solo en RUNNING */
    if(g_state==ST_RUNNING){
      if(++tick5ms_acc>=200){
        tick5ms_acc=0;
        if(remaining_s>0){
          remaining_s--;
          sevenseg_set_from_seconds(remaining_s);
          lcd_goto(1,0); print_mm_ss_LCD(remaining_s);
        }
        if(remaining_s==0){
          motor_off();
          g_state=ST_DONE;
          lcd_clear(); lcd_goto(0,0); lcd_puts("Finalizado");
          buzzer_request_beeps(3);
        }
      }
    }

    /* scroll suave en menús largos */
    static uint16_t sc=0;
    if(++sc>=250){ sc=0;
      if(g_state==ST_IDLE){ lcd_goto(0,0); lcd_puts("A=Tiempo  B=Temp"); lcd_goto(1,0); lcd_puts("C=Presets      "); lcd_scroll_once(); }
      if(g_state==ST_PRESETS){ lcd_goto(1,0); lcd_puts(PRESETS[preset_idx].name); lcd_scroll_once(); }
    }

    /* lee tecla lista */
    char k = keypad_get_key();
    if(k) on_key(k);
  }
}

/* ======= Init HW ======= */
static void clock_init(void){
  RCC->CR |= RCC_CR_HSION;
  while(!(RCC->CR & RCC_CR_HSIRDY));
  RCC->CFGR &= ~RCC_CFGR_SW;
  RCC->CFGR |= RCC_CFGR_SW_HSI;
  while((RCC->CFGR & RCC_CFGR_SWS)!=RCC_CFGR_SWS_HSI);
}
static void gpio_init(void){
  RCC->IOPENR |= RCC_IOPENR_IOPAEN | RCC_IOPENR_IOPBEN | RCC_IOPENR_IOPCEN;

  /* PA1..PA8 (salida) + PA9..PA12 leds/buzzer */
  GPIOA->MODER &=
    ~( (3u<<(1*2))|(3u<<(2*2))|(3u<<(3*2))|(3u<<(4*2))|(3u<<(5*2))|(3u<<(6*2))|(3u<<(7*2))|(3u<<(8*2))|
       (3u<<(9*2))|(3u<<(10*2))|(3u<<(11*2))|(3u<<(12*2)) );
  GPIOA->MODER |=
     (1u<<(1*2))|(1u<<(2*2))|(1u<<(3*2))|(1u<<(4*2))|(1u<<(5*2))|(1u<<(6*2))|(1u<<(7*2))|(1u<<(8*2))|
     (1u<<(9*2))|(1u<<(10*2))|(1u<<(11*2))|(1u<<(12*2));

  /* PB0,PB1,PB2,PB10 salidas (dígitos) + PB12..PB15 salidas (filas keypad) */
  GPIOB->MODER &=
    ~( (3u<<(0*2))|(3u<<(1*2))|(3u<<(2*2))|(3u<<(10*2))|
       (3u<<(12*2))|(3u<<(13*2))|(3u<<(14*2))|(3u<<(15*2)) );
  GPIOB->MODER |=
     (1u<<(0*2))|(1u<<(1*2))|(1u<<(2*2))|(1u<<(10*2))|
     (1u<<(12*2))|(1u<<(13*2))|(1u<<(14*2))|(1u<<(15*2));

  /* PC0..PC5 salidas (LCD), PC6..PC9 entradas con pull-up (columnas) */
  GPIOC->MODER &=
    ~( (3u<<(0*2))|(3u<<(1*2))|(3u<<(2*2))|(3u<<(3*2))|(3u<<(4*2))|(3u<<(5*2))|
       (3u<<(6*2))|(3u<<(7*2))|(3u<<(8*2))|(3u<<(9*2)) );
  GPIOC->MODER |=
     (1u<<(0*2))|(1u<<(1*2))|(1u<<(2*2))|(1u<<(3*2))|(1u<<(4*2))|(1u<<(5*2));
  GPIOC->PUPDR &= ~((3u<<(6*2))|(3u<<(7*2))|(3u<<(8*2))|(3u<<(9*2)));
  GPIOC->PUPDR |=  ((1u<<(6*2))|(1u<<(7*2))|(1u<<(8*2))|(1u<<(9*2)));

  sevenseg_all_off();
  gpio_bsrr_clr(LED_PORT, LED_G|LED_Y|LED_R);
  buzzer_init();
}
static void tim21_init_5ms(void){
  RCC->APB2ENR |= RCC_APB2ENR_TIM21EN;
  TIM21->PSC = 16000-1;   /* 16MHz/16000 = 1kHz (1 ms) */
  TIM21->ARR = 5-1;       /* 5 ms */
  TIM21->DIER |= TIM_DIER_UIE;
  TIM21->CR1  |= TIM_CR1_CEN;
  NVIC_EnableIRQ(TIM21_IRQn);
}

/* ======= MAIN ======= */
int main(void){
  clock_init();
  gpio_init();
  tim21_init_5ms();
  lcd_init_blocking();
  ui_refresh_idle();

  sevenseg_set_from_seconds(0);

  for(;;){
    __WFI(); /* todo se maneja por interrupciones */
  }
}


