#include <stdint.h>
#include <stdbool.h>
#include "stm32l0xx.h"   // Requiere macro STM32L053xx definida en el compilador

/* ============================================================
   Pines estilo HAL para proyectos sin HAL (Empty/CMSIS)
   ============================================================ */
#ifndef GPIO_PIN_0
#define GPIO_PIN_0   (1u << 0)
#define GPIO_PIN_1   (1u << 1)
#define GPIO_PIN_2   (1u << 2)
#define GPIO_PIN_3   (1u << 3)
#define GPIO_PIN_4   (1u << 4)
#define GPIO_PIN_5   (1u << 5)
#define GPIO_PIN_6   (1u << 6)
#define GPIO_PIN_7   (1u << 7)
#define GPIO_PIN_8   (1u << 8)
#define GPIO_PIN_9   (1u << 9)
#define GPIO_PIN_10  (1u << 10)
#define GPIO_PIN_11  (1u << 11)
#define GPIO_PIN_12  (1u << 12)
#define GPIO_PIN_13  (1u << 13)
#define GPIO_PIN_14  (1u << 14)
#define GPIO_PIN_15  (1u << 15)
#endif

/* ===================== PIN MAP =====================

7-seg (cátodo común):
  Segmentos A..G,DP -> PA1..PA8  (activos en 1)
  Dígitos (comunes) -> PB0, PB1, PB2, PB10 (ACTIVOS EN 0)

Keypad 4x4:
  Filas  -> PB12, PB13, PB14, PB15 (salidas, activas en 0)
  Columnas -> PC6, PC7, PC8, PC9 (entrada pull-up, activas en 0)

LCD 16x2 (HD44780, 4-bit):
  RS=PC0, E=PC1, D4=PC2, D5=PC3, D6=PC4, D7=PC5

LEDs:
  Verde=PA9, Amarilla=PA10, Rojo=PA11

Buzzer:
  PA12

Motor PWM:
  PA0 = TIM2_CH1 (AF2)

Timers:
  TIM22 -> 1 kHz (multiplex 7-seg)
  TIM21 -> 200 Hz (tick 5 ms)
  TIM2  -> PWM 2 kHz (motor)
==================================================== */

/* ===================== UTILIDADES GPIO ===================== */
static inline void gpio_set(GPIO_TypeDef* g, uint32_t pin){ g->BSRR = pin; }
static inline void gpio_clr(GPIO_TypeDef* g, uint32_t pin){ g->BRR  = pin; }
static inline uint32_t gpio_rd(GPIO_TypeDef* g, uint32_t pin){ return (g->IDR & pin) ? 1u : 0u; }

/* ===================== ENCODING 7-SEG ===================== */
static const uint8_t seg_code[10] = {
  /*gfedcba*/
  0b0111111, //0
  0b0000110, //1
  0b1011011, //2
  0b1001111, //3
  0b1100110, //4
  0b1101101, //5
  0b1111101, //6
  0b0000111, //7
  0b1111111, //8
  0b1101111  //9
};
static uint8_t dig_mmss[4]; // M10,M1,S10,S1
static uint8_t mux_idx = 0;

/* ===================== KEYPAD ===================== */
typedef enum {K_NONE=0,
  K_0,K_1,K_2,K_3,K_4,K_5,K_6,K_7,K_8,K_9,
  K_A,K_B,K_C,K_D,K_STAR,K_HASH
} key_t;

static const key_t keymap[4][4] = {
  {K_1, K_2, K_3, K_A},
  {K_4, K_5, K_6, K_B},
  {K_7, K_8, K_9, K_C},
  {K_STAR, K_0, K_HASH, K_D}
};

#define DEBOUNCE_CYCLES    3      // 3*5ms = 15 ms
#define DOUBLE_WIN_CYCLES  80     // 80*5ms = 400 ms

static uint8_t db_cnt[4][4], stbl[4][4];
static key_t kqueue = K_NONE;
static key_t last_for_double = K_NONE;
static uint16_t dbl_win = 0;
static uint8_t dbl_ready = 0;

/* ===================== LCD 4-bit NO BLOQUEANTE ===================== */
typedef enum {Q_CMD=0, Q_DAT} qtype_t;
typedef struct { qtype_t t; uint8_t b; } qitem_t;
#define QSIZE 64
static qitem_t q[QSIZE];
static volatile uint8_t qh=0, qt=0;
static uint8_t lcd_busy_ticks=0;

static inline void q_en(qtype_t t, uint8_t b){
  uint8_t n=(qh+1)&(QSIZE-1); if(n!=qt){ q[qh].t=t; q[qh].b=b; qh=n; }
}
static inline bool q_de(qitem_t* o){
  if (qt==qh) return false;
  *o = q[qt];
  qt = (qt+1) & (QSIZE-1);
  return true;
}

/* ===================== FSM ===================== */
typedef enum { ST_IDLE=0, ST_SET_TIME, ST_SET_TEMP, ST_SET_PRESET, ST_READY, ST_RUNNING, ST_PAUSED, ST_DONE } state_t;
static state_t st = ST_IDLE;

static uint16_t set_seconds=0, remain_seconds=0;
static uint8_t temp_set=20;
static uint8_t entering=0;       // ingreso numérico
static uint32_t in_num=0;
static uint16_t tick5_acc=0;

/* ===================== HELPERS DE TIEMPO ===================== */
static void sevenseg_set(uint16_t tot){
  uint16_t mm = tot/60, ss = tot%60;
  dig_mmss[0]=(mm/10)%10; dig_mmss[1]=mm%10;
  dig_mmss[2]=(ss/10)%10; dig_mmss[3]=ss%10;
}

/* ===================== HW INIT ===================== */
static void clock_init(void){
  RCC->CR |= RCC_CR_HSION;
  while(!(RCC->CR & RCC_CR_HSIRDY));
  RCC->CFGR = (RCC->CFGR & ~RCC_CFGR_SW) | RCC_CFGR_SW_HSI;
  while(((RCC->CFGR)&RCC_CFGR_SWS)!=RCC_CFGR_SWS_HSI);
}

static void gpio_init(void){
  RCC->IOPENR |= RCC_IOPENR_GPIOAEN | RCC_IOPENR_GPIOBEN | RCC_IOPENR_GPIOCEN;

  // Segmentos PA1..PA8 salida
  GPIOA->MODER &= ~(GPIO_MODER_MODE1|GPIO_MODER_MODE2|GPIO_MODER_MODE3|GPIO_MODER_MODE4|
                    GPIO_MODER_MODE5|GPIO_MODER_MODE6|GPIO_MODER_MODE7|GPIO_MODER_MODE8);
  GPIOA->MODER |=  (1u<<(1*2))|(1u<<(2*2))|(1u<<(3*2))|(1u<<(4*2))|
                   (1u<<(5*2))|(1u<<(6*2))|(1u<<(7*2))|(1u<<(8*2));
  // LEDs + Buzzer PA9..PA12 salida
  GPIOA->MODER &= ~(GPIO_MODER_MODE9|GPIO_MODER_MODE10|GPIO_MODER_MODE11|GPIO_MODER_MODE12);
  GPIOA->MODER |=  (1u<<(9*2))|(1u<<(10*2))|(1u<<(11*2))|(1u<<(12*2));

  // Dígitos PB0,1,2,10 salida
  GPIOB->MODER &= ~(GPIO_MODER_MODE0|GPIO_MODER_MODE1|GPIO_MODER_MODE2|GPIO_MODER_MODE10);
  GPIOB->MODER |=  (1u<<(0*2))|(1u<<(1*2))|(1u<<(2*2))|(1u<<(10*2));

  // Keypad filas PB12..PB15 salida
  GPIOB->MODER &= ~(GPIO_MODER_MODE12|GPIO_MODER_MODE13|GPIO_MODER_MODE14|GPIO_MODER_MODE15);
  GPIOB->MODER |=  (1u<<(12*2))|(1u<<(13*2))|(1u<<(14*2))|(1u<<(15*2));
  // Keypad columnas PC6..PC9 input + pull-up
  GPIOC->MODER &= ~(GPIO_MODER_MODE6|GPIO_MODER_MODE7|GPIO_MODER_MODE8|GPIO_MODER_MODE9);
  GPIOC->PUPDR &= ~(GPIO_PUPDR_PUPD6|GPIO_PUPDR_PUPD7|GPIO_PUPDR_PUPD8|GPIO_PUPDR_PUPD9);
  GPIOC->PUPDR |=  (1u<<(6*2))|(1u<<(7*2))|(1u<<(8*2))|(1u<<(9*2));

  // LCD PC0..PC5 salida
  GPIOC->MODER &= ~(GPIO_MODER_MODE0|GPIO_MODER_MODE1|GPIO_MODER_MODE2|
                    GPIO_MODER_MODE3|GPIO_MODER_MODE4|GPIO_MODER_MODE5);
  GPIOC->MODER |=  (1u<<(0*2))|(1u<<(1*2))|(1u<<(2*2))|
                   (1u<<(3*2))|(1u<<(4*2))|(1u<<(5*2));

  // Motor PA0 AF2 TIM2_CH1
  GPIOA->MODER &= ~GPIO_MODER_MODE0;
  GPIOA->MODER |=  (2u<<(0*2));
  GPIOA->AFR[0] = (GPIOA->AFR[0] & ~(0xFu<<(0*4))) | (2u<<(0*4));
}

static void tim22_1khz_init(void){ // multiplex 7-seg
  RCC->APB2ENR |= RCC_APB2ENR_TIM22EN;
  TIM22->PSC = 16-1;     // 16MHz/16 = 1MHz
  TIM22->ARR = 1000-1;   // 1MHz/1000 = 1kHz
  TIM22->DIER |= TIM_DIER_UIE;
  TIM22->CR1  |= TIM_CR1_CEN;
  NVIC_SetPriority(TIM22_IRQn, 2);
  NVIC_EnableIRQ(TIM22_IRQn);
}

static void tim21_200hz_init(void){ // tick 5 ms
  RCC->APB2ENR |= RCC_APB2ENR_TIM21EN;
  TIM21->PSC = 160-1;    // 16MHz/160=100kHz
  TIM21->ARR = 500-1;    // 100kHz/500=200Hz
  TIM21->DIER |= TIM_DIER_UIE;
  TIM21->CR1  |= TIM_CR1_CEN;
  NVIC_SetPriority(TIM21_IRQn, 1);
  NVIC_EnableIRQ(TIM21_IRQn);
}

static void tim2_pwm_init(void){ // motor
  RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;
  TIM2->PSC = 16-1;      // 16MHz/16=1MHz
  TIM2->ARR = 500-1;     // 2kHz
  TIM2->CCR1 = 0;        // duty 0%
  TIM2->CCMR1 &= ~TIM_CCMR1_OC1M;
  TIM2->CCMR1 |= (6u<<4);                     // PWM1
  TIM2->CCMR1 |= TIM_CCMR1_OC1PE;
  TIM2->CCER   |= TIM_CCER_CC1E;
  TIM2->CR1    |= TIM_CR1_ARPE | TIM_CR1_CEN;
}

/* ===================== 7-SEG DRIVER ===================== */
static void seg_all_off(void){
  // DESHABILITA todos los dígitos: (apagados = 1)
  gpio_set(GPIOB, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_10);
}
static void seg_enable_digit(uint8_t i){
  // Habilita SOLO el seleccionado (encendido = 0)
  switch(i){
    case 0: gpio_clr(GPIOB,GPIO_PIN_0); break;
    case 1: gpio_clr(GPIOB,GPIO_PIN_1); break;
    case 2: gpio_clr(GPIOB,GPIO_PIN_2); break;
    case 3: gpio_clr(GPIOB,GPIO_PIN_10);break;
  }
}
static void seg_set_segments(uint8_t code){
  // A..G en PA1..PA7, DP=PA8  (activos en 1)
  (code & 0x01)? gpio_set(GPIOA,GPIO_PIN_1):gpio_clr(GPIOA,GPIO_PIN_1);
  (code & 0x02)? gpio_set(GPIOA,GPIO_PIN_2):gpio_clr(GPIOA,GPIO_PIN_2);
  (code & 0x04)? gpio_set(GPIOA,GPIO_PIN_3):gpio_clr(GPIOA,GPIO_PIN_3);
  (code & 0x08)? gpio_set(GPIOA,GPIO_PIN_4):gpio_clr(GPIOA,GPIO_PIN_4);
  (code & 0x10)? gpio_set(GPIOA,GPIO_PIN_5):gpio_clr(GPIOA,GPIO_PIN_5);
  (code & 0x20)? gpio_set(GPIOA,GPIO_PIN_6):gpio_clr(GPIOA,GPIO_PIN_6);
  (code & 0x40)? gpio_set(GPIOA,GPIO_PIN_7):gpio_clr(GPIOA,GPIO_PIN_7);
  gpio_clr(GPIOA,GPIO_PIN_8); // DP apagado
}

/* ===================== KEYPAD SCAN (cada 5ms) ===================== */
static void rows_drive(int r){
  // filas inactivas en 1; activa una fila en 0
  gpio_set(GPIOB, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15);
  if (r>=0 && r<=3){
    switch(r){
      case 0: gpio_clr(GPIOB, GPIO_PIN_12); break;
      case 1: gpio_clr(GPIOB, GPIO_PIN_13); break;
      case 2: gpio_clr(GPIOB, GPIO_PIN_14); break;
      case 3: gpio_clr(GPIOB, GPIO_PIN_15); break;
    }
  }
}
static uint8_t read_col(uint8_t c){
  uint16_t pin = (c==0)?GPIO_PIN_6:(c==1)?GPIO_PIN_7:(c==2)?GPIO_PIN_8:GPIO_PIN_9;
  return (gpio_rd(GPIOC,pin)==0)?1u:0u; // activo en 0
}
static void keypad_tick_5ms(void){
  static uint8_t r=0;
  rows_drive(r);
  for(uint8_t c=0;c<4;c++){
    uint8_t p = read_col(c);
    if (p){
      if (db_cnt[r][c]<255) db_cnt[r][c]++;
      if (db_cnt[r][c]>=DEBOUNCE_CYCLES && !stbl[r][c]){
        stbl[r][c]=1;
        key_t k = keymap[r][c];
        kqueue = k;
        if (k==last_for_double && dbl_win>0){ dbl_ready=1; }
        else { last_for_double=k; dbl_win=DOUBLE_WIN_CYCLES; }
      }
    } else {
      if (db_cnt[r][c]>0) db_cnt[r][c]--;
      if (db_cnt[r][c]==0) stbl[r][c]=0;
    }
  }
  if (dbl_win>0) dbl_win--;
  r = (r+1)&0x03;
  if (r==0) rows_drive(-1);
}
static bool keypad_get_key(key_t* out){
  if (kqueue!=K_NONE){ *out=kqueue; kqueue=K_NONE; return true; }
  return false;
}
static bool keypad_double_ready(key_t k){
  if (dbl_ready && last_for_double==k){ dbl_ready=0; last_for_double=K_NONE; return true; }
  return false;
}

/* ===================== LCD 4-bit (registro) ===================== */
static inline void LCD_RS(uint8_t v){ v?gpio_set(GPIOC,GPIO_PIN_0):gpio_clr(GPIOC,GPIO_PIN_0); }
static inline void LCD_EH(void){ gpio_set(GPIOC,GPIO_PIN_1); }
static inline void LCD_EL(void){ gpio_clr(GPIOC,GPIO_PIN_1); }
static inline void LCD_PUT4(uint8_t vh){
  (vh&0x10)?gpio_set(GPIOC,GPIO_PIN_2):gpio_clr(GPIOC,GPIO_PIN_2);
  (vh&0x20)?gpio_set(GPIOC,GPIO_PIN_3):gpio_clr(GPIOC,GPIO_PIN_3);
  (vh&0x40)?gpio_set(GPIOC,GPIO_PIN_4):gpio_clr(GPIOC,GPIO_PIN_4);
  (vh&0x80)?gpio_set(GPIOC,GPIO_PIN_5):gpio_clr(GPIOC,GPIO_PIN_5);
  LCD_EH(); LCD_EL();
}
static void lcd_write8_now(uint8_t v, qtype_t t){
  LCD_RS(t==Q_DAT);
  LCD_PUT4(v & 0xF0);
  LCD_PUT4((v<<4)&0xF0);
  lcd_busy_ticks = 2; // ~10ms distribuidos por tick 5ms
}
static void lcd_tick_5ms(void){
  if (lcd_busy_ticks){ lcd_busy_ticks--; return; }
  qitem_t it;
  if (q_de(&it)){ lcd_write8_now(it.b, it.t); }
}
static void lcd_cmd(uint8_t c){ q_en(Q_CMD,c); }
static void lcd_dat(uint8_t d){ q_en(Q_DAT,d); }
static void lcd_init_async(void){
  lcd_cmd(0x33); lcd_cmd(0x32); lcd_cmd(0x28); // 4-bit, 2 lines
  lcd_cmd(0x0C); // display on, cursor off
  lcd_cmd(0x06); // entry mode
  lcd_cmd(0x01); // clear
}
static void lcd_clear(void){ lcd_cmd(0x01); }
static void lcd_goto(uint8_t row,uint8_t col){
  uint8_t addr=(row==0?0x00:0x40)+col; lcd_cmd(0x80|addr);
}
static void lcd_print(const char* s){ while(*s) lcd_dat((uint8_t)*s++); }
static void lcd_printfix(const char* s, uint8_t n){
  for(uint8_t i=0;i<n;i++){ char c=s[i]; lcd_dat((uint8_t)(c?c:' ')); }
}

/* ===================== BUZZER ===================== */
static uint8_t  beep_left=0, bz_state=0; // 0 idle,1 on,2 off
static uint16_t on_t=0, off_t=0;
static void buzzer_init(void){ gpio_clr(GPIOA,GPIO_PIN_12); }
static void buzzer_beeps(uint8_t n){ beep_left+=n; if(bz_state==0){ bz_state=2; off_t=1; } }
static void buzzer_tick_5ms(void){
  switch(bz_state){
    case 0: break;
    case 1: if(on_t==0){ gpio_clr(GPIOA,GPIO_PIN_12); bz_state=2; off_t=30; } else on_t--; break;
    case 2: if(off_t==0){
              if(beep_left){ beep_left--; gpio_set(GPIOA,GPIO_PIN_12); bz_state=1; on_t=30; }
              else bz_state=0;
            } else off_t--; break;
  }
}

/* ===================== MOTOR PWM ===================== */
static inline void motor_on(void){ TIM2->CCR1 = (TIM2->ARR*60)/100; }
static inline void motor_off(void){ TIM2->CCR1 = 0; }

/* ===================== PRESETS ===================== */
typedef struct { const char* name; uint16_t seconds; } preset_t;
static const preset_t PRESETS[4] = {
  {"Palomitas", 180}, {"Carne", 300}, {"Sopa", 180}, {"Descongelar", 600}
};

/* ===================== LEDS por temperatura ===================== */
static void leds_update(void){
  gpio_clr(GPIOA,GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11);
  if (temp_set>=1 && temp_set<=33) gpio_set(GPIOA,GPIO_PIN_9);
  else if (temp_set<=66)           gpio_set(GPIOA,GPIO_PIN_10);
  else                             gpio_set(GPIOA,GPIO_PIN_11);
}

/* ===================== FSM Y UI ===================== */
static void lcd_show_temp(void){
  lcd_goto(1,0); lcd_print("Temp:");
  uint8_t t=temp_set;
  if (t>=100) { lcd_dat('0'+(t/100)); lcd_dat('0'+((t/10)%10)); lcd_dat('0'+(t%10)); }
  else { lcd_dat(' '); lcd_dat('0'+((t/10)%10)); lcd_dat('0'+(t%10)); }
  lcd_dat('C');
}

static void ui_idle(void){
  lcd_clear(); lcd_goto(0,0); lcd_printfix("IDLE  A=time B=tmp",16);
  lcd_show_temp();
}

static void sevenseg_set_from_seconds(uint16_t tot){ sevenseg_set(tot); }

static void to_ready_if_time(void){
  if (set_seconds>0){
    st=ST_READY;
    lcd_goto(0,0); lcd_printfix("Listo: #=Start  ",16);
    lcd_show_temp();
    sevenseg_set_from_seconds(set_seconds);
  }
}

static void start_run(void){
  if (set_seconds==0 && remain_seconds==0) return;
  if (remain_seconds==0) remain_seconds=set_seconds;
  st=ST_RUNNING; motor_on();
  lcd_goto(0,0); lcd_printfix("RUNNING          ",16);
  lcd_show_temp();
}
static void pause_run(void){
  if (st==ST_RUNNING){
    st=ST_PAUSED; motor_off();
    lcd_goto(0,0); lcd_printfix("PAUSED           ",16);
    lcd_show_temp();
  }
}
static void done_end(void){
  st=ST_DONE; motor_off(); buzzer_beeps(3);
  lcd_goto(0,0); lcd_printfix("DONE             ",16);
  lcd_show_temp();
}
static void clear_lcd_only(void){
  lcd_clear(); lcd_goto(0,0); lcd_printfix("CLEARED          ",16);
  lcd_show_temp();
}

static void parse_time(uint32_t v){
  uint16_t mm=0, ss=0;
  if (v>=100){ mm=v/100; ss=v%100; } else { ss=v; }
  mm += ss/60; ss%=60;
  set_seconds = (mm*60)+ss;
  sevenseg_set_from_seconds(set_seconds);
}

static void fsm_on_key(key_t k){
  if (k==K_HASH && keypad_double_ready(K_HASH)){
    if (st==ST_RUNNING || st==ST_READY || st==ST_PAUSED){
      set_seconds += 10;
      if (st==ST_RUNNING) remain_seconds += 10; else remain_seconds=set_seconds;
      sevenseg_set_from_seconds((st==ST_RUNNING)?remain_seconds:set_seconds);
    }
    return;
  }
  if (k==K_STAR && keypad_double_ready(K_STAR)){
    set_seconds=0; remain_seconds=0; sevenseg_set_from_seconds(0); ui_idle(); st=ST_IDLE; return;
  }

  switch(k){
    case K_A: st=ST_SET_TIME; entering=1; in_num=0; lcd_goto(0,0); lcd_printfix("Set TIME mmss    ",16); break;
    case K_B: st=ST_SET_TEMP; entering=1; in_num=0; lcd_goto(0,0); lcd_printfix("Set TEMP 1..100  ",16); break;
    case K_C: st=ST_SET_PRESET; entering=0;  lcd_goto(0,0); lcd_printfix("Preset 1..4 +#   ",16); break;
    case K_D:
      if (st==ST_SET_TEMP && entering){
        if (in_num>=1 && in_num<=100){ temp_set=(uint8_t)in_num; leds_update(); lcd_show_temp(); to_ready_if_time(); }
        else { lcd_goto(0,0); lcd_printfix("TEMP INVALIDA    ",16); }
        entering=0;
      }
      break;
    case K_HASH:
      if (st==ST_READY || st==ST_PAUSED) start_run();
      break;
    case K_STAR:
      if (st==ST_RUNNING) pause_run(); else clear_lcd_only();
      break;
    default:
      if (k>=K_0 && k<=K_9){
        uint8_t d=(uint8_t)(k-K_0);
        if (st==ST_SET_TIME && entering){
          in_num = (in_num*10)+d; if (in_num>9999) in_num%=10000;
          lcd_goto(1,0); lcd_print("T=");
          char buf[5]={'0'+(in_num/1000)%10,'0'+(in_num/100)%10,'0'+(in_num/10)%10,'0'+(in_num%10),0};
          lcd_print(buf);
        } else if (st==ST_SET_TEMP && entering){
          in_num = (in_num*10)+d; if (in_num>999) in_num%=1000;
          lcd_goto(1,0); lcd_print("Tmp=");
          char b2[4]={ (in_num>=100)?'0'+(in_num/100):' ', '0'+((in_num/10)%10), '0'+(in_num%10), 0};
          lcd_print(b2);
        } else if (st==ST_SET_PRESET){
          if (d>=1 && d<=4){
            set_seconds = PRESETS[d-1].seconds;
            lcd_goto(1,0); lcd_printfix(PRESETS[d-1].name,16);
            sevenseg_set_from_seconds(set_seconds); st=ST_READY;
          }
        }
      }
      break;
  }

  if (st==ST_SET_TIME && entering && (k==K_D || k==K_HASH)){
    parse_time(in_num); entering=0; to_ready_if_time();
  }
}

/* ===================== TICKS 5ms ===================== */
static void fsm_tick_5ms(void){
  if (++tick5_acc>=200){ // 1 s
    tick5_acc=0;
    if (st==ST_RUNNING){
      if (remain_seconds>0){
        remain_seconds--;
        sevenseg_set_from_seconds(remain_seconds);
        if (remain_seconds==0) done_end();
      }
    }
  }
  key_t k; if (keypad_get_key(&k)) fsm_on_key(k);
}

/* ===================== IRQ HANDLERS ===================== */
void TIM22_IRQHandler(void){            /* 1 kHz: multiplex 7-seg */
  if (TIM22->SR & TIM_SR_UIF){
    TIM22->SR &= ~TIM_SR_UIF;
    seg_all_off();
    seg_set_segments(seg_code[ dig_mmss[mux_idx] ]);
    seg_enable_digit(mux_idx);
    mux_idx = (mux_idx+1)&0x03;
  }
}

void TIM21_IRQHandler(void){            /* 5 ms: keypad/LCD/buzzer/FSM */
  if (TIM21->SR & TIM_SR_UIF){
    TIM21->SR &= ~TIM_SR_UIF;
    keypad_tick_5ms();
    lcd_tick_5ms();
    buzzer_tick_5ms();
    fsm_tick_5ms();
  }
}

/* ===================== MAIN ===================== */
int main(void){
  clock_init();
  gpio_init();
  tim22_1khz_init();
  tim21_200hz_init();
  tim2_pwm_init();

  buzzer_init();
  leds_update();
  sevenseg_set_from_seconds(0);
  lcd_init_async();

  // UI inicial
  lcd_clear(); lcd_goto(0,0); lcd_printfix("IDLE  A=time B=tmp",16);
  lcd_show_temp();

  for(;;){ __NOP(); } // todo por interrupciones
}
