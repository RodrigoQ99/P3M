/* main.c – NUCLEO-L053R8 (Empty/CMSIS)
   Correcciones:
   - LCD clear/home con espera >1.5ms (evita perder primera letra).
   - Presets (C) rotan opciones una por una.
   - * : 1 vez = backspace (en edición) / pausa (si corre); 2 veces = reset total.
   - # : inicia desde cualquier estado con tiempo válido; doble # = +10s.
   - Al terminar: "Finalizado".
*/

#include "stm32l0xx.h"
#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>

/* ===== Configurables ===== */
#define MENU_SCROLL_PERIOD_MS   750   /* velocidad del scroll del menú Idle (línea 1) */
#define PRESET_ROTATE_MS        1500  /* cada cuánto cambia la opción mostrada en C */
#define DOUBLE_KEY_WINDOW_MS    300   /* ventana para detectar doble * o doble # */

#ifndef GPIO_PIN_0
#define GPIO_PIN_0   (1u<<0)
#define GPIO_PIN_1   (1u<<1)
#define GPIO_PIN_2   (1u<<2)
#define GPIO_PIN_3   (1u<<3)
#define GPIO_PIN_4   (1u<<4)
#define GPIO_PIN_5   (1u<<5)
#define GPIO_PIN_6   (1u<<6)
#define GPIO_PIN_7   (1u<<7)
#define GPIO_PIN_8   (1u<<8)
#define GPIO_PIN_9   (1u<<9)
#define GPIO_PIN_10  (1u<<10)
#define GPIO_PIN_11  (1u<<11)
#define GPIO_PIN_12  (1u<<12)
#define GPIO_PIN_13  (1u<<13)
#define GPIO_PIN_14  (1u<<14)
#define GPIO_PIN_15  (1u<<15)
#endif

/* ========================= PIN MAP =========================
   7-seg (cátodo común):
     A..G,DP -> PA1..PA8  (330Ω)
     D1..D4  -> PB0, PB1, PB2, PB10 (activos en 0)
   Keypad 4x4:
     Filas -> PB12..PB15 (salidas, activas en 0)
     Columnas -> PC6..PC9 (entradas pull-up)
   LCD 16x2 (4-bit):
     RS=PC0, E=PC1, D4..D7=PC2..PC5 (RW->GND, V0 con pot 10k)
   LEDs: PA9/PA10/PA11   Buzzer: PA12
============================================================= */

#define SEG_CC  1   /* 1=cátodo común */

#define QSIZE 16

/* GPIO helpers */
static inline void gpio_set(GPIO_TypeDef *p, uint32_t pin){ p->BSRR = pin; }
static inline void gpio_clr(GPIO_TypeDef *p, uint32_t pin){ p->BRR  = pin; }
static inline uint32_t gpio_rd(GPIO_TypeDef *p, uint32_t pin){ return (p->IDR & pin); }

/* Sistema/UI */
static volatile uint8_t  tick5ms=0;
typedef enum { ST_IDLE=0, ST_SET_TIME, ST_SET_TEMP, ST_PRESET, ST_RUNNING, ST_PAUSE } state_t;
static volatile state_t fsm_state = ST_IDLE;

static volatile uint16_t time_set_s=0, time_left_s=0;
static volatile uint8_t  temp_set=0;
static uint8_t have_temp=0;

/* Cola de teclas */
static uint8_t q[QSIZE]; static uint8_t qh=0, qt=0;
static inline bool q_put(uint8_t v){ uint8_t n=(qh+1)&(QSIZE-1); if(n==qt) return false; q[qh]=v; qh=n; return true; }
static inline bool q_get(uint8_t *o){ if(qt==qh) return false; *o=q[qt]; qt=(qt+1)&(QSIZE-1); return true; }

/* 7-seg */
static const uint8_t DIGCODE[16] = {
  0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,0x77,0x7C,0x39,0x5E,0x79,0x71
};
static uint8_t seg_code[4]={0,0,0,0};
static uint8_t mux_idx=0;

/* Scroll LCD Idle */
static const char menu_text[]="A=tiempo   B=temp   C=presets   ";
static uint16_t menu_scroll_acc=0, menu_pos=0;

/* Presets (rotación en C) */
static const char* PRESET_NAMES[4] = {"Palomitas 3:00","Carne 5:00","Sopa 3:00","Congelado 10:00"};
static const uint16_t PRESET_TIMES[4] = {180, 300, 180, 600};
static uint16_t preset_acc=0; static uint8_t preset_idx=0;

/* Prototipos */
static void clock_init(void);
static void gpio_init(void);
static void tim21_init_5ms(void);
static void leds_update(void);
static void buzzer_init(void);
static void buzzer_tick_5ms(void);
static void keypad_tick_5ms(void);
static void lcd_tick_5ms(void);
static void fsm_tick_5ms(void);

/* LCD 4-bit */
static void lcd_pulse(void);
static void lcd_put4(uint8_t vh);
static void lcd_cmd(uint8_t c);
static void lcd_data(uint8_t d);
static void lcd_init_blocking(void);
static void lcd_clear(void);
static void lcd_goto(uint8_t col,uint8_t row);
static void lcd_puts(const char *s);
static void lcd_print_window16(const char *s,uint16_t len,uint16_t start);

/* 7-seg helpers */
static void seg_all_off(void);
static void seg_enable_digit(uint8_t i);
static void seg_set_segments(uint8_t code,uint8_t dp_on);

/* utils tiempo */
static void fmt_mmss(uint16_t sec,char *out);
static uint16_t raw_to_seconds(uint16_t raw);
static void show_time_7seg(uint16_t s);

/* ====== Doble tecla window ====== */
static uint8_t last_hash=0, hash_window=0, last_star=0, star_window=0;

/* ====================== MAIN ====================== */
int main(void){
  clock_init();
  gpio_init();
  tim21_init_5ms();
  buzzer_init();

  lcd_init_blocking();
  lcd_clear();
  lcd_goto(0,0); lcd_puts("A=tiempo B=temp");
  lcd_goto(0,1); lcd_puts("Temp: --C");

  show_time_7seg(0);
  __enable_irq();

  for(;;){
    if(tick5ms){
      tick5ms=0;
      keypad_tick_5ms();
      lcd_tick_5ms();
      buzzer_tick_5ms();
      fsm_tick_5ms();

      /* multiplex 7-seg */
      seg_all_off();
      seg_set_segments(seg_code[mux_idx], (mux_idx==1)?1:0); /* DP en dígito 2 como “:” */
      seg_enable_digit(mux_idx);
      mux_idx=(mux_idx+1)&3;
    }
  }
}

/* ============ Reloj/Timers ============ */
static void clock_init(void){
  RCC->CR |= RCC_CR_HSION; while(!(RCC->CR & RCC_CR_HSIRDY));
  RCC->CFGR = (RCC->CFGR & ~RCC_CFGR_SW) | RCC_CFGR_SW_HSI;
  RCC->IOPENR |= RCC_IOPENR_IOPAEN|RCC_IOPENR_IOPBEN|RCC_IOPENR_IOPCEN;
  RCC->APB2ENR |= RCC_APB2ENR_TIM21EN;
}
static void tim21_init_5ms(void){
  TIM21->PSC=1599; TIM21->ARR=50-1; TIM21->CNT=0;
  TIM21->DIER|=TIM_DIER_UIE; TIM21->CR1|=TIM_CR1_CEN;
  NVIC_EnableIRQ(TIM21_IRQn);
}
void TIM21_IRQHandler(void){
  if(TIM21->SR & TIM_SR_UIF){ TIM21->SR = ~TIM_SR_UIF; tick5ms=1; }
}

/* ============ GPIO ============ */
static void gpio_init(void){
  for(uint8_t i=1;i<=12;i++){ GPIOA->MODER&=~(3u<<(i*2)); GPIOA->MODER|=(1u<<(i*2)); }
  uint8_t pinsB[]={0,1,2,10,12,13,14,15};
  for(uint8_t k=0;k<8;k++){ uint8_t p=pinsB[k]; GPIOB->MODER&=~(3u<<(p*2)); GPIOB->MODER|=(1u<<(p*2)); }
  for(uint8_t i=0;i<=5;i++){ GPIOC->MODER&=~(3u<<(i*2)); GPIOC->MODER|=(1u<<(i*2)); }
  for(uint8_t i=6;i<=9;i++){ GPIOC->MODER&=~(3u<<(i*2)); GPIOC->PUPDR&=~(3u<<(i*2)); GPIOC->PUPDR|=(1u<<(i*2)); }

#if SEG_CC
  gpio_clr(GPIOA, GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8);
#else
  gpio_set(GPIOA, GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8);
#endif
  gpio_set(GPIOB, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15); /* filas inactivas */
  gpio_clr(GPIOA, GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11|GPIO_PIN_12);  /* LEDs+buzzer off */
  seg_all_off();
}

/* ============ 7-seg ============ */
static void seg_all_off(void){
#if SEG_CC
  gpio_set(GPIOB,GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_10);
#else
  gpio_clr(GPIOB,GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_10);
#endif
}
static void seg_enable_digit(uint8_t i){
#if SEG_CC
  switch(i){ case 0:gpio_clr(GPIOB,GPIO_PIN_0);break; case 1:gpio_clr(GPIOB,GPIO_PIN_1);break;
             case 2:gpio_clr(GPIOB,GPIO_PIN_2);break; case 3:gpio_clr(GPIOB,GPIO_PIN_10);break; }
#else
  switch(i){ case 0:gpio_set(GPIOB,GPIO_PIN_0);break; case 1:gpio_set(GPIOB,GPIO_PIN_1);break;
             case 2:gpio_set(GPIOB,GPIO_PIN_2);break; case 3:gpio_set(GPIOB,GPIO_PIN_10);break; }
#endif
}
static void seg_set_segments(uint8_t code,uint8_t dp_on){
  for(uint8_t b=0;b<7;b++){
    uint32_t pin=(GPIO_PIN_1<<b); /* PA1..PA7 */
#if SEG_CC
    if(code&(1u<<b)) gpio_set(GPIOA,pin); else gpio_clr(GPIOA,pin);
#else
    if(code&(1u<<b)) gpio_clr(GPIOA,pin); else gpio_set(GPIOA,pin);
#endif
  }
#if SEG_CC
  if(dp_on) gpio_set(GPIOA,GPIO_PIN_8); else gpio_clr(GPIOA,GPIO_PIN_8);
#else
  if(dp_on) gpio_clr(GPIOA,GPIO_PIN_8); else gpio_set(GPIOA,GPIO_PIN_8);
#endif
}
static void show_time_7seg(uint16_t s){
  uint8_t mT=(s/60)/10, mU=(s/60)%10, sT=(s%60)/10, sU=(s%60)%10;
  seg_code[0]=DIGCODE[mT]; seg_code[1]=DIGCODE[mU]; seg_code[2]=DIGCODE[sT]; seg_code[3]=DIGCODE[sU];
}

/* ============ LCD (4-bit) ============ */
static inline void LCD_RS(uint8_t v){ v?gpio_set(GPIOC,GPIO_PIN_0):gpio_clr(GPIOC,GPIO_PIN_0); }
static inline void LCD_EH(void){ gpio_set(GPIOC,GPIO_PIN_1); }
static inline void LCD_EL(void){ gpio_clr(GPIOC,GPIO_PIN_1); }
static inline void LCD_PUT4(uint8_t vh){
  (vh&0x10)?gpio_set(GPIOC,GPIO_PIN_2):gpio_clr(GPIOC,GPIO_PIN_2);
  (vh&0x20)?gpio_set(GPIOC,GPIO_PIN_3):gpio_clr(GPIOC,GPIO_PIN_3);
  (vh&0x40)?gpio_set(GPIOC,GPIO_PIN_4):gpio_clr(GPIOC,GPIO_PIN_4);
  (vh&0x80)?gpio_set(GPIOC,GPIO_PIN_5):gpio_clr(GPIOC,GPIO_PIN_5);
}
static void lcd_pulse(void){ LCD_EH(); for(volatile int i=0;i<40;i++) __NOP(); LCD_EL(); }
static void lcd_put4(uint8_t vh){ LCD_PUT4(vh); lcd_pulse(); }

/* IMPORTANTE: clear/home requieren >1.5ms. lcd_cmd diferencia. */
static void lcd_cmd(uint8_t c){
  LCD_RS(0); lcd_put4(c&0xF0); lcd_put4(c<<4);
  if(c==0x01 || c==0x02){ for(volatile int i=0;i<32000;i++) __NOP(); } /* ~2ms@16MHz */
  else                  { for(volatile int i=0;i<900;i++)   __NOP(); } /* ~55us */
}
static void lcd_data(uint8_t d){ LCD_RS(1); lcd_put4(d&0xF0); lcd_put4(d<<4); for(volatile int i=0;i<300;i++) __NOP(); }
static void lcd_init_blocking(void){
  for(volatile int i=0;i<40000;i++) __NOP(); /* >15ms */
  LCD_RS(0); LCD_EL();
  lcd_put4(0x30); for(volatile int i=0;i<10000;i++) __NOP();
  lcd_put4(0x30); for(volatile int i=0;i<2000;i++)  __NOP();
  lcd_put4(0x20); for(volatile int i=0;i<2000;i++)  __NOP();
  lcd_cmd(0x28); lcd_cmd(0x08); lcd_cmd(0x01); lcd_cmd(0x06); lcd_cmd(0x0C);
}
static void lcd_clear(void){ lcd_cmd(0x01); }
static void lcd_goto(uint8_t col,uint8_t row){ lcd_cmd(0x80 + (row?0x40:0x00) + col); }
static void lcd_puts(const char *s){ while(*s) lcd_data(*s++); }
static void lcd_print_window16(const char *s,uint16_t len,uint16_t start){
  char b[17]; for(int i=0;i<16;i++) b[i]=s[(start+i)%len]; b[16]='\0';
  lcd_goto(0,0); lcd_puts(b);
}

/* ============ Keypad ============ */
static const char keymap[4][4]={{'1','2','3','A'},{'4','5','6','B'},{'7','8','9','C'},{'*','0','#','D'}};
static uint8_t row=0;
static void keypad_tick_5ms(void){
  gpio_set(GPIOB,GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15);
  gpio_clr(GPIOB,(GPIO_PIN_12<<row));
  uint8_t c0=!!gpio_rd(GPIOC,GPIO_PIN_6), c1=!!gpio_rd(GPIOC,GPIO_PIN_7);
  uint8_t c2=!!gpio_rd(GPIOC,GPIO_PIN_8), c3=!!gpio_rd(GPIOC,GPIO_PIN_9);
  uint8_t cols=(c0<<0)|(c1<<1)|(c2<<2)|(c3<<3);
  for(uint8_t col=0; col<4; col++){
    static uint8_t st[4][4]={{1,1,1,1},{1,1,1,1},{1,1,1,1},{1,1,1,1}};
    uint8_t val=(cols>>col)&1;
    if(st[row][col] && !val){ q_put((uint8_t)keymap[row][col]); st[row][col]=0; }
    else if(!st[row][col] && val){ st[row][col]=1; }
  }
  row=(row+1)&3;
}

/* ============ Buzzer / LEDs ============ */
static uint8_t bz_state=0; static uint16_t on_t=0, off_ticks=0, left_beeps=0;
static void buzzer_init(void){ gpio_clr(GPIOA,GPIO_PIN_12); }
static void buzzer_beep3(void){ bz_state=1; on_t=30; off_ticks=30; left_beeps=3; }
static void buzzer_tick_5ms(void){
  switch(bz_state){
    case 0: break;
    case 1:
      if(on_t==0){ gpio_set(GPIOA,GPIO_PIN_12); bz_state=2; off_ticks=30; }
      else { gpio_clr(GPIOA,GPIO_PIN_12); on_t--; }
      break;
    case 2:
      if(off_ticks==0){
        if(--left_beeps==0){ gpio_clr(GPIOA,GPIO_PIN_12); bz_state=0; }
        else { bz_state=1; on_t=30; }
      } else {
        off_ticks--;
      }
      break;
  }
}
static void leds_update(void){
  gpio_clr(GPIOA,GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11);
  if(temp_set<=33) gpio_set(GPIOA,GPIO_PIN_9);
  else if(temp_set<=66) gpio_set(GPIOA,GPIO_PIN_10);
  else gpio_set(GPIOA,GPIO_PIN_11);
}

/* ===== Utiles tiempo ===== */
static void fmt_mmss(uint16_t s,char *out){
  uint16_t m=s/60, ss=s%60;
  out[0]='0'+((m/10)%10); out[1]='0'+(m%10); out[2]=':'; out[3]='0'+(ss/10); out[4]='0'+(ss%10); out[5]='\0';
}
static uint16_t raw_to_seconds(uint16_t raw){ return (raw/100u)*60u + (raw%100u); }

/* ====== Edit buffers y control ====== */
static uint16_t edit_time_raw=0, edit_temp_raw=0;
static uint16_t sec_acc_run=0;

/* Backspace helpers para edición */
static void backspace_time(void){
  edit_time_raw /= 10;
  uint16_t s=raw_to_seconds(edit_time_raw); char t[6]; fmt_mmss(s,t);
  lcd_goto(0,0); lcd_puts("Tiempo        ");
  lcd_goto(0,1); lcd_puts("Valor: "); lcd_puts(t); lcd_puts("  ");
  time_set_s=s; show_time_7seg(time_set_s);
}
static void backspace_temp(void){
  edit_temp_raw /= 10;
  if(edit_temp_raw>100) edit_temp_raw=100;
  char l2[17]; snprintf(l2,sizeof(l2),"Valor: %3uC   ",(unsigned)edit_temp_raw);
  lcd_goto(0,1); lcd_puts(l2);
}

/* ============ LCD UI (Idle & Presets rotativos) ============ */
static void lcd_tick_5ms(void){
  if(fsm_state==ST_IDLE){
    menu_scroll_acc+=5;
    if(menu_scroll_acc>=MENU_SCROLL_PERIOD_MS){
      menu_scroll_acc=0;
      menu_pos=(menu_pos+1)%((uint16_t)(sizeof(menu_text)-1));
      lcd_print_window16(menu_text,(uint16_t)(sizeof(menu_text)-1),menu_pos);
      lcd_goto(0,1);
      if(have_temp){ char l2[17]; snprintf(l2,sizeof(l2),"Temp: %02uC",temp_set); lcd_puts(l2); }
      else lcd_puts("Temp: --C     ");
    }
  } else if(fsm_state==ST_PRESET){
    /* Rotar opciones una por una */
    preset_acc+=5;
    if(preset_acc>=PRESET_ROTATE_MS){
      preset_acc=0;
      preset_idx=(preset_idx+1)&3;
      lcd_clear();
      lcd_goto(0,0); lcd_puts("Presets");
      lcd_goto(0,1); lcd_puts(PRESET_NAMES[preset_idx]);
    }
  }
}

/* ============ FSM ============ */
static void start_if_possible(void){
  if(time_set_s>0){
    time_left_s=time_set_s; show_time_7seg(time_left_s);
    lcd_clear(); lcd_goto(0,0); lcd_puts("Calentando");
    sec_acc_run=0; fsm_state=ST_RUNNING;
  }
}
static void reset_all_to_idle(void){
  time_left_s=0; time_set_s=0; edit_time_raw=0; edit_temp_raw=0;
  show_time_7seg(0); preset_idx=0; preset_acc=0;
  lcd_clear(); lcd_goto(0,0); lcd_puts("A=tiempo B=temp");
  lcd_goto(0,1); lcd_puts("Temp: --C");
  fsm_state=ST_IDLE;
}

static void fsm_tick_5ms(void){
  uint8_t k;
  while(q_get(&k)){
    if(k=='#'){
      /* doble # => +10s cuando está corriendo o en pausa */
      if(hash_window && !last_hash){
        if(fsm_state==ST_RUNNING || fsm_state==ST_PAUSE){
          time_left_s+=10; show_time_7seg(time_left_s);
        }
        last_hash=1; continue;
      }
      last_hash=1; hash_window=1;

      /* iniciar desde cualquier estado con tiempo válido */
      if(fsm_state==ST_IDLE || fsm_state==ST_SET_TIME || fsm_state==ST_PRESET || fsm_state==ST_PAUSE){
        start_if_possible();
      }
    }
    else if(k=='*'){
      /* doble * => reset total a Idle */
      if(star_window && !last_star){
        reset_all_to_idle();
        last_star=1; continue;
      }
      last_star=1; star_window=1;

      /* una vez: pausa si corre; backspace si edita; limpiar línea si no */
      if(fsm_state==ST_RUNNING){
        fsm_state=ST_PAUSE; lcd_clear(); lcd_goto(0,0); lcd_puts("Pausa");
      } else if(fsm_state==ST_SET_TIME){
        backspace_time();
      } else if(fsm_state==ST_SET_TEMP){
        backspace_temp();
      } else {
        lcd_clear(); /* limpiar visual sin resetear variables */
        if(have_temp){ lcd_goto(0,1); char l2[17]; snprintf(l2,sizeof(l2),"Temp: %02uC",temp_set); lcd_puts(l2); }
      }
    }
    else if(k=='A'){
      fsm_state=ST_SET_TIME; edit_time_raw=0;
      lcd_clear(); lcd_goto(0,0); lcd_puts("Tiempo");
      lcd_goto(0,1); lcd_puts("Valor: 00:00");
    }
    else if(k=='B'){
      fsm_state=ST_SET_TEMP; edit_temp_raw=0;
      lcd_clear(); lcd_goto(0,0); lcd_puts("Temperatura");
      lcd_goto(0,1); lcd_puts("Valor:   0C");
    }
    else if(k=='C'){
      fsm_state=ST_PRESET; preset_idx=0; preset_acc=0;
      lcd_clear(); lcd_goto(0,0); lcd_puts("Presets");
      lcd_goto(0,1); lcd_puts(PRESET_NAMES[preset_idx]);
      /* seleccionar preset con 1..4 también sigue activo abajo */
    }
    else if(k>='0' && k<='9'){
      if(fsm_state==ST_SET_TIME){
        if(edit_time_raw<1000) edit_time_raw=edit_time_raw*10+(k-'0');
        uint16_t s=raw_to_seconds(edit_time_raw); char t[6]; fmt_mmss(s,t);
        lcd_goto(0,0); lcd_puts("Tiempo        ");
        lcd_goto(0,1); lcd_puts("Valor: "); lcd_puts(t); lcd_puts("  ");
        time_set_s=s; show_time_7seg(time_set_s);
      } else if(fsm_state==ST_SET_TEMP){
        if(edit_temp_raw<100) edit_temp_raw=edit_temp_raw*10+(k-'0');
        if(edit_temp_raw>100) edit_temp_raw=100;
        char l2[17]; snprintf(l2,sizeof(l2),"Valor: %3uC   ",(unsigned)edit_temp_raw);
        lcd_goto(0,1); lcd_puts(l2);
      } else if(fsm_state==ST_PRESET){
        if(k>='1' && k<='4'){
          uint8_t idx=(uint8_t)(k-'1');
          time_set_s=PRESET_TIMES[idx];
          lcd_clear(); lcd_goto(0,0); lcd_puts(PRESET_NAMES[idx]);
          lcd_goto(0,1); lcd_puts("Listo: #");
          show_time_7seg(time_set_s);
        }
      }
    }
    else if(k=='D' && fsm_state==ST_SET_TEMP){
      temp_set=(uint8_t)edit_temp_raw; have_temp=1; leds_update();
      lcd_clear(); lcd_goto(0,0); lcd_puts("Temp guardada");
      char l2[17]; snprintf(l2,sizeof(l2),"Temp: %02uC",temp_set); lcd_goto(0,1); lcd_puts(l2);
      fsm_state=ST_IDLE;
    }
  }

  /* Ventanas de doble tecla */
  if(hash_window){ static uint16_t t=0; t+=5; if(t>=DOUBLE_KEY_WINDOW_MS){ t=0; hash_window=0; last_hash=0; } }
  if(star_window){ static uint16_t t=0; t+=5; if(t>=DOUBLE_KEY_WINDOW_MS){ t=0; star_window=0; last_star=0; } }

  /* Conteo cuando corre */
  if(fsm_state==ST_RUNNING){
    sec_acc_run+=5;
    if(sec_acc_run>=1000){
      sec_acc_run=0;
      if(time_left_s>0){
        time_left_s--; show_time_7seg(time_left_s);
        char t[6]; fmt_mmss(time_left_s,t);
        lcd_goto(0,0); lcd_puts("Calentando     ");
        lcd_goto(0,1); lcd_puts("Tiempo: "); lcd_puts(t); lcd_puts("  ");
      }else{
        fsm_state=ST_IDLE; buzzer_beep3();
        lcd_clear(); lcd_goto(0,0); lcd_puts("Finalizado");
        show_time_7seg(0);
      }
    }
  }
}
