/* main.c  –  NUCLEO-L053R8 (Empty/CMSIS)
 * Entradas/salidas y comportamiento descritos en el encabezado del mensaje.
 * Compila con STM32CubeIDE 1.19 y paquete FW_L0 v1.12.x
 */

#include "stm32l0xx.h"
#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>

/* ========================= PIN MAP =========================
   7-seg (cátodo común):
     Segmentos A..G,DP -> PA1..PA8  (cada uno con 330Ω)
     Dígitos (comunes) -> PB0, PB1, PB2, PB10  (activos en 0)

   Keypad 4x4:
     Filas  -> PB12, PB13, PB14, PB15 (salidas, activas en 0)
     Columnas -> PC6, PC7, PC8, PC9  (entradas con pull-up)

   LCD 16x2 (HD44780, 4-bit):
     RS=PC0, E=PC1, D4=PC2, D5=PC3, D6=PC4, D7=PC5
     RW->GND, V0 a wiper de pot 10k entre +5V/GND
     Backlight A->5V (100–220Ω), K->GND

   LEDs temperatura:
     Verde=PA9, Amarilla=PA10, Roja=PA11 (activos en 1, con 330Ω)

   Buzzer:
     PA12 (activa en 1, ON/OFF por software)
   ========================================================= */

#define SEG_CC   1   /* 1=cátodo común; si tu display fuera ánodo, pon 0 e invierte lógica más abajo */

#define QSIZE 16

/* ---------------- Helpers GPIO (rápidos) ---------------- */
static inline void gpio_set(GPIO_TypeDef *p, uint32_t pin) { p->BSRR = pin; }
static inline void gpio_clr(GPIO_TypeDef *p, uint32_t pin) { p->BRR  = pin; }
static inline uint32_t gpio_rd(GPIO_TypeDef *p, uint32_t pin){ return (p->IDR & pin); }

/* =============== Globals de sistema/UI ================== */
static volatile uint32_t ms = 0;          /* milisegundos */
static volatile uint8_t  tick5ms = 0;     /* flag 5 ms */

typedef enum { ST_IDLE=0, ST_SET_TIME, ST_SET_TEMP, ST_PRESET, ST_RUNNING, ST_PAUSE } state_t;
static volatile state_t fsm_state = ST_IDLE;

/* tiempo (segundos) */
static volatile uint16_t time_set_s = 0;   /* tiempo configurado */
static volatile uint16_t time_left_s = 0;  /* contador */

static volatile uint8_t temp_set = 0;     /* 0..100 */
static uint8_t have_temp = 0;

/* --------------- Cola simple de teclas ------------------ */
static uint8_t q[QSIZE]; static uint8_t qh=0, qt=0;
static inline bool q_put(uint8_t v){ uint8_t n=(qh+1)&(QSIZE-1); if(n==qt) return false; q[qh]=v; qh=n; return true; }
static inline bool q_get(uint8_t *o){ if(qt==qh) return false; *o=q[qt]; qt=(qt+1)&(QSIZE-1); return true; }

/* --------------- Mapa 7-seg y multiplex ----------------- */
/* code bit0=A, bit1=B, ... bit6=G */
static const uint8_t DIGCODE[16] = {
  /*0*/ 0x3F, /*1*/0x06, /*2*/0x5B, /*3*/0x4F, /*4*/0x66,
  /*5*/ 0x6D, /*6*/0x7D, /*7*/0x07, /*8*/0x7F, /*9*/0x6F,
  /*A*/ 0x77, /*b*/0x7C, /*C*/0x39, /*d*/0x5E, /*E*/0x79, /*F*/0x71
};

static uint8_t seg_code[4] = {0,0,0,0};
static uint8_t mux_idx = 0;

/* --------------- Texto scroll para LCD ------------------ */
static const char menu_text[] = "A=tiempo   B=temp   C=presets   ";
static uint16_t menu_scroll_acc = 0;
static uint16_t menu_pos = 0;

/* --------------- Prototipos ------------------------------ */
static void clock_init(void);
static void gpio_init(void);
static void tim21_init_5ms(void);
static void leds_update(void);
static void buzzer_init(void);
static void buzzer_tick_5ms(void);
static void keypad_tick_5ms(void);
static void lcd_tick_5ms(void);
static void fsm_tick_5ms(void);

/* LCD (bloques rápidos en 4-bit) */
static void lcd_pulse(void);
static void lcd_put4(uint8_t vh);
static void lcd_cmd(uint8_t c);
static void lcd_data(uint8_t d);
static void lcd_init_blocking(void);
static void lcd_clear(void);
static void lcd_goto(uint8_t col, uint8_t row);
static void lcd_puts(const char *s);
static void lcd_print_window16(const char *s, uint16_t len, uint16_t start);

/* 7-seg helpers */
static void seg_all_off(void);
static void seg_enable_digit(uint8_t i);
static void seg_set_segments(uint8_t code, uint8_t dp_on);

/* utils tiempo */
static void fmt_mmss(uint16_t sec, char *out);
static uint16_t raw_to_seconds(uint16_t raw);

/* ======================================================== */
/*                        MAIN                              */
/* ======================================================== */
int main(void)
{
  clock_init();
  gpio_init();
  tim21_init_5ms();
  buzzer_init();

  /* LCD: init y pantalla de inicio */
  lcd_init_blocking();
  lcd_clear();
  lcd_goto(0,0); lcd_puts("A=tiempo B=temp");
  lcd_goto(0,1); lcd_puts("Temp: --C");
  menu_pos = 0; menu_scroll_acc = 0; have_temp = 0;

  /* 7-seg: mostrar 00:00 al inicio */
  seg_code[0] = DIGCODE[0];
  seg_code[1] = DIGCODE[0];
  seg_code[2] = DIGCODE[0];
  seg_code[3] = DIGCODE[0];

  __enable_irq();

  for(;;){
    if(tick5ms){
      tick5ms = 0;
      /* orden de servicio cada 5ms */
      keypad_tick_5ms();
      lcd_tick_5ms();
      buzzer_tick_5ms();
      fsm_tick_5ms();

      /* multiplex 7-seg */
      seg_all_off();
      /* DP encendido en el segundo dígito para simular ":" */
      seg_set_segments(seg_code[mux_idx], (mux_idx==1)?1:0);
      seg_enable_digit(mux_idx);
      mux_idx = (mux_idx + 1) & 0x03;
    }
  }
}

/* ==================== Reloj/Timers ====================== */
static void clock_init(void)
{
  /* HSI16 como SYSCLK */
  RCC->CR |= RCC_CR_HSION;
  while(!(RCC->CR & RCC_CR_HSIRDY));
  RCC->CFGR = (RCC->CFGR & ~RCC_CFGR_SW) | RCC_CFGR_SW_HSI;

  /* GPIO A,B,C */
  RCC->IOPENR |= RCC_IOPENR_IOPAEN | RCC_IOPENR_IOPBEN | RCC_IOPENR_IOPCEN;

  /* TIM21 */
  RCC->APB2ENR |= RCC_APB2ENR_TIM21EN;
}

static void tim21_init_5ms(void)
{
  /* fTIM = 16MHz / (PSC+1). Para tick 5ms: ARR = fTIM*0.005 -1
     Tomemos PSC=1599 => f=10kHz; ARR=50-1 => 5ms */
  TIM21->PSC = 1599;
  TIM21->ARR = 50-1;
  TIM21->CNT = 0;
  TIM21->DIER |= TIM_DIER_UIE;
  TIM21->CR1  |= TIM_CR1_CEN;
  NVIC_EnableIRQ(TIM21_IRQn);
}

void TIM21_IRQHandler(void)
{
  if(TIM21->SR & TIM_SR_UIF){
    TIM21->SR = ~TIM_SR_UIF;
    ms += 5;
    tick5ms = 1;
  }
}

/* ===================== GPIO Init ======================== */
static void gpio_init(void)
{
  /* PA1..PA12 como salida (segmentos A..G,DP + LEDs + buzzer) */
  /* PA0 es libre; PA1..PA12: set output (01) */
  for(uint8_t i=1;i<=12;i++){
    GPIOA->MODER &= ~(3u << (i*2));
    GPIOA->MODER |=  (1u << (i*2));
  }

  /* PB0,PB1,PB2,PB10 (dígitos) como salida */
  uint8_t pinsB[] = {0,1,2,10,12,13,14,15};
  for(uint8_t k=0;k<8;k++){
    uint8_t p=pinsB[k];
    GPIOB->MODER &= ~(3u << (p*2));
    GPIOB->MODER |=  (1u << (p*2));
  }

  /* PC0..PC5 (LCD) como salida */
  for(uint8_t i=0;i<=5;i++){
    GPIOC->MODER &= ~(3u << (i*2));
    GPIOC->MODER |=  (1u << (i*2));
  }
  /* PC6..PC9 (keypad columnas) entrada + pull-up */
  for(uint8_t i=6;i<=9;i++){
    GPIOC->MODER &= ~(3u << (i*2));            /* input */
    GPIOC->PUPDR &= ~(3u << (i*2));
    GPIOC->PUPDR |=  (1u << (i*2));            /* pull-up */
  }

  /* estados iniciales */
  /* 7-seg apagado */
  seg_all_off();
  /* segmentos OFF según cátodo común: poner en 0 */
#if SEG_CC
  gpio_clr(GPIOA, GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4|
                   GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8);
#else
  gpio_set(GPIOA, GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4|
                   GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8);
#endif
  /* keypad filas en 1 (inactivas) -> PB12..PB15 */
  gpio_set(GPIOB, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15);

  /* LEDs off, buzzer off */
  gpio_clr(GPIOA, GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11|GPIO_PIN_12);
}

/* ===================== 7-seg ============================ */
static void seg_all_off(void)
{
#if SEG_CC
  /* apagar = poner comunes EN 1 */
  gpio_set(GPIOB, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_10);
#else
  gpio_clr(GPIOB, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_10);
#endif
}

static void seg_enable_digit(uint8_t i)
{
#if SEG_CC
  switch(i){
    case 0: gpio_clr(GPIOB,GPIO_PIN_0); break;
    case 1: gpio_clr(GPIOB,GPIO_PIN_1); break;
    case 2: gpio_clr(GPIOB,GPIO_PIN_2); break;
    case 3: gpio_clr(GPIOB,GPIO_PIN_10); break;
  }
#else
  switch(i){
    case 0: gpio_set(GPIOB,GPIO_PIN_0); break;
    case 1: gpio_set(GPIOB,GPIO_PIN_1); break;
    case 2: gpio_set(GPIOB,GPIO_PIN_2); break;
    case 3: gpio_set(GPIOB,GPIO_PIN_10); break;
  }
#endif
}

static void seg_set_segments(uint8_t code, uint8_t dp_on)
{
  /* A..G */
  for(uint8_t b=0;b<7;b++){
    uint32_t pin = (GPIO_PIN_1 << b); /* PA1..PA7 */
#if SEG_CC
    if(code & (1u<<b)) gpio_set(GPIOA,pin); else gpio_clr(GPIOA,pin);
#else
    if(code & (1u<<b)) gpio_clr(GPIOA,pin); else gpio_set(GPIOA,pin);
#endif
  }
  /* DP (PA8) lo usamos de ":" */
#if SEG_CC
  if(dp_on) gpio_set(GPIOA,GPIO_PIN_8); else gpio_clr(GPIOA,GPIO_PIN_8);
#else
  if(dp_on) gpio_clr(GPIOA,GPIO_PIN_8); else gpio_set(GPIOA,GPIO_PIN_8);
#endif
}

/* ===================== LCD (4-bit) ====================== */
static inline void LCD_RS(uint8_t v){ v?gpio_set(GPIOC,GPIO_PIN_0):gpio_clr(GPIOC,GPIO_PIN_0); }
static inline void LCD_EH(void){ gpio_set(GPIOC,GPIO_PIN_1); }
static inline void LCD_EL(void){ gpio_clr(GPIOC,GPIO_PIN_1); }
static inline void LCD_PUT4(uint8_t vh)
{
  (vh&0x10)?gpio_set(GPIOC,GPIO_PIN_2):gpio_clr(GPIOC,GPIO_PIN_2);
  (vh&0x20)?gpio_set(GPIOC,GPIO_PIN_3):gpio_clr(GPIOC,GPIO_PIN_3);
  (vh&0x40)?gpio_set(GPIOC,GPIO_PIN_4):gpio_clr(GPIOC,GPIO_PIN_4);
  (vh&0x80)?gpio_set(GPIOC,GPIO_PIN_5):gpio_clr(GPIOC,GPIO_PIN_5);
}

static void lcd_pulse(void){ LCD_EH(); for(volatile int i=0;i<40;i++) __NOP(); LCD_EL(); }
static void lcd_put4(uint8_t vh){ LCD_PUT4(vh); lcd_pulse(); }
static void lcd_cmd(uint8_t c){ LCD_RS(0); lcd_put4(c&0xF0); lcd_put4(c<<4); for(volatile int i=0;i<800;i++) __NOP(); }
static void lcd_data(uint8_t d){ LCD_RS(1); lcd_put4(d&0xF0); lcd_put4(d<<4); }

static void lcd_init_blocking(void)
{
  for(volatile int i=0;i<40000;i++) __NOP__(); /* >15ms */
  LCD_RS(0); LCD_EL(); /* RW está a GND */
  /* secuencia init 4-bit */
  lcd_put4(0x30); for(volatile int i=0;i<10000;i++) __NOP__();
  lcd_put4(0x30); for(volatile int i=0;i<2000;i++) __NOP__();
  lcd_put4(0x20); for(volatile int i=0;i<2000;i++) __NOP__();
  lcd_cmd(0x28); /* 4bit, 2 line */
  lcd_cmd(0x08); /* display off */
  lcd_cmd(0x01); /* clear */
  lcd_cmd(0x06); /* entry inc */
  lcd_cmd(0x0C); /* display on, cursor off */
}

static void lcd_clear(void){ lcd_cmd(0x01); }
static void lcd_goto(uint8_t col, uint8_t row){ lcd_cmd(0x80 + (row?0x40:0x00) + col); }
static void lcd_puts(const char *s){ while(*s) lcd_data(*s++); }

static void lcd_print_window16(const char *s, uint16_t len, uint16_t start)
{
  char buf[17];
  for(int i=0;i<16;i++) buf[i] = s[(start+i)%len];
  buf[16]='\0';
  lcd_goto(0,0); lcd_puts(buf);
}

/* ==================== Keypad scan ======================= */
/*  Matriz:
    Fila baja a 0 una por vez (PB12..PB15).
    Columnas PC6..PC9 con pull-up (0 = pulsado).
*/
static const char keymap[4][4] = {
  {'1','2','3','A'},
  {'4','5','6','B'},
  {'7','8','9','C'},
  {'*','0','#','D'}
};
static uint8_t row=0, deb[4]={0xFF,0xFF,0xFF,0xFF};

static void keypad_tick_5ms(void)
{
  /* desactiva filas (1) */
  gpio_set(GPIOB, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15);

  /* activa la fila "row" bajándola a 0 */
  gpio_clr(GPIOB, (GPIO_PIN_12<<row));

  /* lee columnas y debounce (cada bit: 1=alto, 0=bajo) */
  uint8_t c0 = !!gpio_rd(GPIOC,GPIO_PIN_6);
  uint8_t c1 = !!gpio_rd(GPIOC,GPIO_PIN_7);
  uint8_t c2 = !!gpio_rd(GPIOC,GPIO_PIN_8);
  uint8_t c3 = !!gpio_rd(GPIOC,GPIO_PIN_9);

  uint8_t cols = (c0<<0)|(c1<<1)|(c2<<2)|(c3<<3); /* 1=sueltos */
  deb[row] = (deb[row]<<1) | (cols==0x0F); /* simple filtro */
  /* detectar pulsación: cuando alguna col pasa a 0 estable */
  for(uint8_t col=0; col<4; col++){
    uint8_t val = ( (cols>>col)&1 );
    static uint8_t st[4][4] = {{1,1,1,1},{1,1,1,1},{1,1,1,1},{1,1,1,1}};
    if(st[row][col] && !val){  /* 1->0: pulsado */
      q_put( (uint8_t)keymap[row][col] );
      st[row][col] = 0;
    }else if(!st[row][col] && val){ /* 0->1: liberado */
      st[row][col] = 1;
    }
  }

  row = (row+1)&3;
}

/* ==================== Buzzer/LEDs ======================= */
static uint8_t bz_state=0; static uint16_t on_t=0, off_t=0, left_beeps=0;

static void buzzer_init(void){ gpio_clr(GPIOA,GPIO_PIN_12); }
static void buzzer_beep3(void){ bz_state=1; on_t=30; off_t=30; left_beeps=3; }

static void buzzer_tick_5ms(void)
{
  switch(bz_state){
    case 0: break;
    case 1:
      if(on_t==0){ gpio_set(GPIOA,GPIO_PIN_12); bz_state=2; off_t=30; }
      else { gpio_clr(GPIOA,GPIO_PIN_12); on_t--; }
      break;
    case 2:
      if(off_t==0){
        if(--left_beeps==0){ gpio_clr(GPIOA,GPIO_PIN_12); bz_state=0; }
        else { bz_state=1; on_t=30; }
      }else off_t--;
      break;
  }
}

static void leds_update(void)
{
  /* PA9/10/11 = verde/amar/roja */
  gpio_clr(GPIOA, GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11);
  if(temp_set<=33) gpio_set(GPIOA,GPIO_PIN_9);
  else if(temp_set<=66) gpio_set(GPIOA,GPIO_PIN_10);
  else gpio_set(GPIOA,GPIO_PIN_11);
}

/* ==================== LCD UI tick ======================= */
static void fmt_mmss(uint16_t sec, char *out){
  uint16_t m = sec/60, s=sec%60;
  out[0]='0'+((m/10)%10); out[1]='0'+(m%10); out[2]=':'; out[3]='0'+(s/10); out[4]='0'+(s%10); out[5]='\0';
}
static uint16_t raw_to_seconds(uint16_t raw){ return (raw/100u)*60u + (raw%100u); }

static uint16_t edit_time_raw = 0;
static uint16_t edit_temp_raw = 0;

static void lcd_tick_5ms(void)
{
  /* Scroll de menú cuando estamos en IDLE */
  if(fsm_state == ST_IDLE){
    menu_scroll_acc += 5;
    if(menu_scroll_acc >= 250){
      menu_scroll_acc = 0;
      menu_pos = (menu_pos + 1) % (sizeof(menu_text)-1);
      lcd_print_window16(menu_text, (uint16_t)(sizeof(menu_text)-1), menu_pos);
      lcd_goto(0,1);
      if(have_temp) {
        char l2[17]; char t[6]; fmt_mmss(time_set_s, t);
        snprintf(l2,sizeof(l2),"Temp: %02uC", temp_set);
        lcd_puts(l2);
      } else {
        lcd_puts("Temp: --C     ");
      }
    }
  }
}

/* ====================== FSM ============================= */
static uint16_t sec_acc=0;     /* acumula 5ms para 1000ms */
static uint8_t  last_hash=0, hash_window=0;  /* para detectar doble # */
static uint8_t  last_star=0, star_window=0;

static void show_time_7seg(uint16_t s)
{
  uint8_t mT = (s/60)/10;
  uint8_t mU = (s/60)%10;
  uint8_t sT = (s%60)/10;
  uint8_t sU = (s%60)%10;
  seg_code[0] = DIGCODE[mT];
  seg_code[1] = DIGCODE[mU];
  seg_code[2] = DIGCODE[sT];
  seg_code[3] = DIGCODE[sU];
}

static void fsm_tick_5ms(void)
{
  /* Procesa teclas */
  uint8_t k;
  while(q_get(&k)){
    if(k=='#'){
      if(hash_window && !last_hash){ /* segundo # dentro de ventana */
        if(fsm_state==ST_RUNNING || fsm_state==ST_PAUSE){ time_left_s += 10; show_time_7seg(time_left_s); }
        last_hash=1; continue;
      }
      last_hash=1; hash_window=1;
      if(fsm_state==ST_IDLE && time_set_s>0){ time_left_s=time_set_s; show_time_7seg(time_left_s);
        lcd_clear(); lcd_goto(0,0); lcd_puts("Calentando"); fsm_state=ST_RUNNING; }
      else if(fsm_state==ST_PAUSE){ fsm_state=ST_RUNNING; lcd_clear(); lcd_goto(0,0); lcd_puts("Calentando"); }
    }
    else if(k=='*'){
      if(star_window && !last_star){ /* doble * => reset */
        time_left_s=0; time_set_s=0; show_time_7seg(0);
        lcd_clear(); lcd_goto(0,0); lcd_puts("A=tiempo B=temp");
        lcd_goto(0,1); lcd_puts("Temp: --C");
        fsm_state=ST_IDLE;
        last_star=1; continue;
      }
      last_star=1; star_window=1;
      if(fsm_state==ST_RUNNING){ fsm_state=ST_PAUSE; lcd_clear(); lcd_goto(0,0); lcd_puts("Pausa"); }
      else { lcd_clear(); lcd_goto(0,0); lcd_puts("                "); lcd_goto(0,1); lcd_puts("                "); }
    }
    else if(k=='A'){ fsm_state=ST_SET_TIME; edit_time_raw=0; lcd_clear(); lcd_goto(0,0); lcd_puts("Tiempo"); lcd_goto(0,1); lcd_puts("Valor: 00:00"); }
    else if(k=='B'){ fsm_state=ST_SET_TEMP; edit_temp_raw=0; lcd_clear(); lcd_goto(0,0); lcd_puts("Temperatura"); lcd_goto(0,1); lcd_puts("Valor:   0C"); }
    else if(k=='C'){ fsm_state=ST_PRESET; lcd_clear(); lcd_goto(0,0); lcd_puts("Presets 1..4"); lcd_goto(0,1); lcd_puts("1:Palo 2:Carne"); }
    else if(k>='0' && k<='9'){
      if(fsm_state==ST_SET_TIME){
        /* arma raw (mmss) con 4 digitos máx */
        if(edit_time_raw<1000) edit_time_raw = edit_time_raw*10 + (k-'0');
        uint16_t s = raw_to_seconds(edit_time_raw);
        char t[6]; fmt_mmss(s,t);
        lcd_goto(0,0); lcd_puts("Tiempo        ");
        lcd_goto(0,1); lcd_puts("Valor: "); lcd_puts(t); lcd_puts("  ");
        time_set_s = s; show_time_7seg(time_set_s);
      }else if(fsm_state==ST_SET_TEMP){
        if(edit_temp_raw<100) edit_temp_raw = edit_temp_raw*10 + (k-'0');
        if(edit_temp_raw>100) edit_temp_raw=100;
        char l2[17]; snprintf(l2,sizeof(l2),"Valor: %3uC   ", (unsigned)edit_temp_raw);
        lcd_goto(0,1); lcd_puts(l2);
      }else if(fsm_state==ST_PRESET){
        if(k=='1'){ time_set_s=180; lcd_clear(); lcd_goto(0,0); lcd_puts("Palomitas"); lcd_goto(0,1); lcd_puts("Listo: #"); }
        else if(k=='2'){ time_set_s=300; lcd_clear(); lcd_goto(0,0); lcd_puts("Carne"); lcd_goto(0,1); lcd_puts("Listo: #"); }
        else if(k=='3'){ time_set_s=180; lcd_clear(); lcd_goto(0,0); lcd_puts("Sopa"); lcd_goto(0,1); lcd_puts("Listo: #"); }
        else if(k=='4'){ time_set_s=600; lcd_clear(); lcd_goto(0,0); lcd_puts("Descongelar"); lcd_goto(0,1); lcd_puts("Listo: #"); }
        show_time_7seg(time_set_s);
      }
    }else if(k=='D' && fsm_state==ST_SET_TEMP){
      temp_set = (uint8_t)edit_temp_raw; have_temp=1; leds_update();
      lcd_clear(); lcd_goto(0,0); lcd_puts("Temp guardada");
      char l2[17]; snprintf(l2,sizeof(l2),"Temp: %02uC", temp_set); lcd_goto(0,1); lcd_puts(l2);
      fsm_state = ST_IDLE;
    }
  }

  /* Ventanas para doble # / * (300ms) */
  if(hash_window){ static uint16_t t=0; t+=5; if(t>=300){ t=0; hash_window=0; last_hash=0; } }
  if(star_window){ static uint16_t t=0; t+=5; if(t>=300){ t=0; star_window=0; last_star=0; } }

  /* Contador de tiempo cuando corre */
  if(fsm_state==ST_RUNNING){
    sec_acc += 5;
    if(sec_acc>=1000){ sec_acc=0;
      if(time_left_s>0){
        time_left_s--;
        show_time_7seg(time_left_s);
        /* LCD: Calentando + Tiempo mm:ss */
        char t[6];
        fmt_mmss(time_left_s, t);
        lcd_goto(0,0); lcd_puts("Calentando     ");
        lcd_goto(0,1); lcd_puts("Tiempo: "); lcd_puts(t); lcd_puts("  ");
      }else{
        fsm_state = ST_IDLE;
        buzzer_beep3();
        lcd_clear(); lcd_goto(0,0); lcd_puts("Listo");
        show_time_7seg(0);
      }
    }
  }
}

/* ========================= FIN ========================== */

