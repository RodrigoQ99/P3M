#include "stm32l053xx.h"
#include <stdint.h>
#include <stdbool.h>

/* ===================== Configurables ===================== */
#define LCD_I2C_ADDR_7B      0x27     // PCF8574 común (0x27) en 7 bits
#define SCROLL_PERIOD_MS     400      // velocidad legible para scroll
#define KEYPAD_SCAN_MS       5
#define DOUBLE_D_WINDOW_MS   300
#define BUZZ_TONE_HZ         2000
#define MOTOR_PWM_FREQ_HZ    1000

/* Bebidas (ms) */
#define T_CAPUCHINO_MS       60000
#define T_EXPRESSO_MS        30000
#define T_LATE_MS            80000
#define T_AMERICANO_MS       45000

/* PWM duty (0..1000) */
#define DUTY_OFF             0
#define DUTY_MEDIO           500
#define DUTY_ALTO            850

/* ===================== Pines ===================== */
/* LCD I2C1: PB6=SCL, PB7=SDA (AF1) */
/* Keypad R0..R3: PB0..PB3 (salida)  C0..C3: PB4,PB5,PB8,PB9 (entrada pull-up) */
#define KP_R_PORT   GPIOB
#define KP_C_PORT   GPIOB

#define KP_R0_PIN   (1u<<0)
#define KP_R1_PIN   (1u<<1)
#define KP_R2_PIN   (1u<<2)
#define KP_R3_PIN   (1u<<3)

#define KP_C0_PIN   (1u<<4)
#define KP_C1_PIN   (1u<<5)
#define KP_C2_PIN   (1u<<8)
#define KP_C3_PIN   (1u<<9)

/* LEDs: PC0 rojo, PC1 amarillo, PC2 azul */
#define LED_PORT    GPIOC
#define LED_R_PIN   (1u<<0)
#define LED_Y_PIN   (1u<<1)
#define LED_B_PIN   (1u<<2)

/* Motor PWM: PA0 TIM2_CH1 */
#define MOTOR_PORT  GPIOA
#define MOTOR_PIN   (1u<<0)

/* Buzzer: PA1 TIM21_CH2 */
#define BUZZ_PORT   GPIOA
#define BUZZ_PIN    (1u<<1)

/* ===================== LCD via PCF8574 wiring (típico) =====================
   PCF8574 -> LCD: P0=D4, P1=D5, P2=D6, P3=D7, P4=EN, P5=RW, P6=RS, P7=BL
   RW=0 siempre (escritura). BL=1 encendido.
========================================================================== */
#define LCD_BL      0x80
#define LCD_EN      0x10
#define LCD_RW      0x20
#define LCD_RS      0x40

/* ===================== Estados ===================== */
typedef enum {
  APP_IDLE = 0,
  APP_MENU,
  APP_SIZE,
  APP_RUN,
  APP_PAUSE,
  APP_DONE
} app_state_t;

typedef enum {
  PH1 = 0, // Iniciando
  PH2,     // Preparando
  PH3      // sirviendo
} phase_t;

/* ===================== Globals ===================== */
static volatile uint32_t ms = 0;

static volatile app_state_t app = APP_IDLE;
static volatile phase_t phase = PH1;

static volatile uint8_t bebida = 0;      // 1..4
static volatile uint8_t size_sel = 2;    // 1=P,2=M,3=G (default M)
static volatile bool bebida_ok = false;
static volatile bool size_ok   = false;

static volatile uint32_t t_total_ms = 0;
static volatile uint32_t t_phase_ms = 0;
static volatile uint32_t t_rem_ms   = 0;
static volatile uint32_t t_phase_rem_ms = 0;

static volatile uint32_t scroll_ms_acc = 0;
static volatile uint8_t  scroll_idx = 0;

/* Doble D */
static volatile uint32_t last_D_time = 0;
static volatile bool     d_pressed_recent = false;

/* Keypad */
static volatile char key_event = 0;   // último key detectado (consumido por SysTick)
static uint8_t kp_row = 0;            // fila activa (0..3)
static char kp_map[4][4] = {
  {'1','2','3','A'},
  {'4','5','6','B'},
  {'7','8','9','C'},
  {'*','0','#','D'}
};
static volatile char kp_last = 0;
static volatile uint8_t kp_stable_cnt = 0;

/* Buzzer (2 beeps) */
static volatile uint8_t  buzz_beeps_left = 0;
static volatile uint32_t buzz_phase_ms   = 0;
static volatile bool     buzz_on         = false;

/* UI flags (para evitar escribir LCD en cada ms) */
static volatile bool ui_dirty = true;

/* Buffers UI */
static const char *idle_text = "Selecciona una opcion   ";
static const char *menu_text = "1=Capuchino 2=Expresso 3=Late 4=Americano   ";
static char line1[17] = {0};
static char line2[17] = {0};

/* ===================== Prototipos ===================== */
static void clock_init(void);
static void gpio_init(void);
static void i2c1_init_100k(void);
static void lcd_init(void);
static void lcd_cmd(uint8_t c);
static void lcd_data(uint8_t d);
static void lcd_write_nibble(uint8_t en_rs_bl, uint8_t nib);
static void lcd_goto(uint8_t row, uint8_t col);
static void lcd_puts_aligned(const char *s);
static void lcd_clear(void);
static void lcd_puts(const char *s);
static void lcd_puts_len(const char* s, uint8_t len);

static void motor_pwm_init(void);
static void motor_set_duty(uint16_t duty_0_1000);

static void tim22_init_keypad_scan(void);
static void keypad_drive_row(uint8_t r);
static uint8_t keypad_read_cols(void);

static void buzz_timer_init(void);
static void buzz_start(void);
static void buzz_stop(void);
static void buzz_schedule_2(void);

static void set_leds(bool r, bool y, bool b);
static void start_bebida(uint8_t b);
static void apply_phase_outputs(void);
static void ui_refresh(void);
static void ui_show_time_remaining(void);

/* ===================== Main ===================== */
int main(void)
{
  clock_init();
  gpio_init();
  i2c1_init_100k();
  lcd_init();
  motor_pwm_init();
  buzz_timer_init();
  tim22_init_keypad_scan();

  /* SysTick 1ms @16MHz */
  SysTick->LOAD = 16000 - 1;
  SysTick->VAL  = 0;
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk;

  /* Pantalla inicial */
  lcd_clear();
  lcd_goto(0,0); lcd_puts("Selecciona una");
  lcd_goto(1,0); lcd_puts("opcion");
  set_leds(false,false,false);

  while(1) {
    __WFI();  // dormimos; todo se resuelve por interrupción
  }
}

/* ===================== Interrupciones ===================== */
void SysTick_Handler(void)
{
  ms++;

  /* Procesa tecla si hay */
  if (key_event != 0) {
    char k = key_event; key_event = 0;

    if (k >= '1' && k <= '4') {
      /* Número elegido en MENU */
      if (app == APP_MENU) {
        bebida = (uint8_t)(k - '0');
        bebida_ok = false; // aún no confirmado
        ui_dirty = true;
      }
      if (app == APP_SIZE) {
        if (k >= '1' && k <= '3') {
          size_sel = (uint8_t)(k - '0'); // 1=P,2=M,3=G
        }
        ui_dirty = true;
      }
    }
    else if (k == 'A') {
      /* Ir al menú desde IDLE */
      app = APP_MENU;
      bebida_ok = false;
      ui_dirty = true;
    }
    else if (k == 'B') {
      /* Selección de tamaño */
      app = APP_SIZE;
      ui_dirty = true;
    }
    else if (k == 'C') {
      /* Confirmar */
      if (app == APP_MENU && (bebida >=1 && bebida <=4)) {
        bebida_ok = true;
        ui_dirty = true;
      } else if (app == APP_SIZE) {
        size_ok = true; // opcional
        app = APP_MENU;
        ui_dirty = true;
      }
    }
    else if (k == 'D') {
      /* Borrar / doble D para volver a inicio */
      uint32_t now = ms;
      if (d_pressed_recent && (now - last_D_time) <= DOUBLE_D_WINDOW_MS) {
        // volver a inicio
        app = APP_IDLE;
        bebida = 0; bebida_ok = false;
        size_sel = 2; size_ok = false;
        t_total_ms = t_phase_ms = t_rem_ms = t_phase_rem_ms = 0;
        motor_set_duty(DUTY_OFF);
        set_leds(false,false,false);
        ui_dirty = true;
        d_pressed_recent = false;
      } else {
        // limpiar selección
        bebida = 0; bebida_ok = false;
        size_ok = false;
        d_pressed_recent = true;
        last_D_time = now;
        ui_dirty = true;
      }
    }
    else if (k == '*') {
      /* Iniciar proceso si confirmado */
      if ((app == APP_MENU) && bebida_ok) {
        start_bebida(bebida);
        app = APP_RUN;
        ui_dirty = true;
      }
    }
    else if (k == '#') {
      /* Pausa/resume */
      if (app == APP_RUN) {
        app = APP_PAUSE;
        motor_set_duty(DUTY_OFF);
        lcd_clear();
        lcd_goto(0,0); lcd_puts("Pausa");
      } else if (app == APP_PAUSE) {
        app = APP_RUN;
        apply_phase_outputs();
        ui_dirty = true;
      }
    }
  }

  /* Caducidad de la ventanilla de doble D */
  if (d_pressed_recent && (ms - last_D_time) > DOUBLE_D_WINDOW_MS) {
    d_pressed_recent = false;
  }

  /* Scroll UI (solo IDLE o MENU) */
  scroll_ms_acc += 1;
  if (scroll_ms_acc >= SCROLL_PERIOD_MS) {
    scroll_ms_acc = 0;
    if (app == APP_IDLE || app == APP_MENU) {
      ui_dirty = true;
      scroll_idx++;
    }
  }

  /* Timer de ejecución del proceso */
  if (app == APP_RUN) {
    if (t_rem_ms > 0) {
      t_rem_ms--;
      if (t_phase_rem_ms > 0) t_phase_rem_ms--;
      else {
        /* Cambio de fase */
        if (phase == PH1) { phase = PH2; t_phase_rem_ms = t_phase_ms; apply_phase_outputs(); }
        else if (phase == PH2) { phase = PH3; t_phase_rem_ms = t_phase_ms; apply_phase_outputs(); }
      }
      if ((t_rem_ms % 1000) == 0) ui_dirty = true; // refrescar tiempo 1/s
    } else {
      /* Terminado */
      app = APP_DONE;
      motor_set_duty(DUTY_OFF);
      set_leds(false,false,false);
      lcd_clear();
      lcd_goto(0,0); lcd_puts("Disfrutalo");
      buzz_schedule_2();
    }
  }

  /* Buzzer patrón (2 beeps) */
  if (buzz_beeps_left > 0) {
    buzz_phase_ms++;
    if (buzz_on) {
      if (buzz_phase_ms >= 200) { // 200 ms ON
        buzz_stop();
        buzz_on = false;
        buzz_phase_ms = 0;
      }
    } else {
      if (buzz_phase_ms >= 200) { // 200 ms OFF
        buzz_phase_ms = 0;
        buzz_start();
        buzz_on = true;
        buzz_beeps_left--;
      }
    }
  }

  /* UI refresh diferido */
  if (ui_dirty) {
    ui_dirty = false;
    ui_refresh();
  }
}

/* Keypad scan cada 5 ms */
void TIM22_IRQHandler(void)
{
  if (TIM22->SR & TIM_SR_UIF) {
    TIM22->SR = ~TIM_SR_UIF;

    // activar fila actual
    keypad_drive_row(kp_row);
    // leer columnas
    uint8_t cols = keypad_read_cols(); // bits 0..3 (1=alto, 0=presionado)
    char k = 0;
    for (int c=0;c<4;c++) {
      if (((cols >> c) & 0x1) == 0) { // presionado
        k = kp_map[kp_row][c];
        break;
      }
    }

    if (k == kp_last) {
      if (k != 0 && kp_stable_cnt < 3) kp_stable_cnt++;
      if (kp_stable_cnt == 2) { // estable ~10ms
        key_event = k;
      }
    } else {
      kp_last = k;
      kp_stable_cnt = 0;
    }

    // siguiente fila
    kp_row = (kp_row + 1) & 0x3;
  }
}

/* ===================== Init / HW ===================== */
static void clock_init(void)
{
  /* HSI16 ON */
  RCC->CR |= RCC_CR_HSION;
  while(!(RCC->CR & RCC_CR_HSIRDY));
  RCC->CFGR &= ~RCC_CFGR_SW;
  RCC->CFGR |= RCC_CFGR_SW_HSI; // SYSCLK = HSI16
}

static void gpio_init(void)
{
  RCC->IOPENR |= RCC_IOPENR_GPIOAEN | RCC_IOPENR_GPIOBEN | RCC_IOPENR_GPIOCEN;

  /* LEDs PC0..PC2 output */
  LED_PORT->MODER &= ~((3u<<(0*2))|(3u<<(1*2))|(3u<<(2*2)));
  LED_PORT->MODER |=  ((1u<<(0*2))|(1u<<(1*2))|(1u<<(2*2)));
  set_leds(false,false,false);

  /* Motor PA0 AF (TIM2_CH1) */
  MOTOR_PORT->MODER &= ~(3u<<(0*2));
  MOTOR_PORT->MODER |=  (2u<<(0*2)); // AF
  /* AF para TIM2_CH1 en PA0 -> AF2 (en L0xx) */
  GPIOA->AFR[0] &= ~(0xF<<(0*4));
  GPIOA->AFR[0] |=  (2u<<(0*4));

  /* Buzzer PA1 AF (TIM21_CH2) */
  BUZZ_PORT->MODER &= ~(3u<<(1*2));
  BUZZ_PORT->MODER |=  (2u<<(1*2));
  /* TIM21_CH2 en PA1 -> AF6 (L0xx) */
  GPIOA->AFR[0] &= ~(0xF<<(1*4));
  GPIOA->AFR[0] |=  (6u<<(1*4));

  /* Keypad filas PB0..PB3 salida (push-pull) */
  KP_R_PORT->MODER &= ~((3u<<(0*2))|(3u<<(1*2))|(3u<<(2*2))|(3u<<(3*2)));
  KP_R_PORT->MODER |=  ((1u<<(0*2))|(1u<<(1*2))|(1u<<(2*2))|(1u<<(3*2)));
  KP_R_PORT->ODR |= (KP_R0_PIN|KP_R1_PIN|KP_R2_PIN|KP_R3_PIN); // inactivas en alto

  /* Keypad columnas PB4,PB5,PB8,PB9 entrada con pull-up */
  KP_C_PORT->MODER &= ~((3u<<(4*2))|(3u<<(5*2))|(3u<<(8*2))|(3u<<(9*2)));
  KP_C_PORT->PUPDR &= ~((3u<<(4*2))|(3u<<(5*2))|(3u<<(8*2))|(3u<<(9*2)));
  KP_C_PORT->PUPDR |=  ((1u<<(4*2))|(1u<<(5*2))|(1u<<(8*2))|(1u<<(9*2)));
}

static void i2c1_init_100k(void)
{
  RCC->APB1ENR |= RCC_APB1ENR_I2C1EN;

  /* PB6/PB7 AF1 Open-Drain Pull-up */
  GPIOB->MODER &= ~((3u<<(6*2))|(3u<<(7*2)));
  GPIOB->MODER |=  ((2u<<(6*2))|(2u<<(7*2)));
  GPIOB->OTYPER |=  ( (1u<<6) | (1u<<7) );
  GPIOB->OSPEEDR |= ((3u<<(6*2))|(3u<<(7*2)));
  GPIOB->AFR[0] &= ~((0xF<<(6*4))|(0xF<<(7*4)));
  GPIOB->AFR[0] |=  ((1u<<(6*4))|(1u<<(7*4)));

  I2C1->CR1 &= ~I2C_CR1_PE;
  I2C1->TIMINGR = 0x00303D5B; // 100kHz @16MHz (típico en L0)
  I2C1->CR1 = I2C_CR1_PE;
}

static void motor_pwm_init(void)
{
  RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;
  /* Freq PWM = MOTOR_PWM_FREQ_HZ */
  uint32_t pclk = 16000000;
  uint32_t presc = 0;
  uint32_t arr = (pclk / MOTOR_PWM_FREQ_HZ) - 1; // sin prescaler
  TIM2->PSC = presc;
  TIM2->ARR = arr;
  TIM2->CCR1 = 0;
  TIM2->CCMR1 = (6u<<4); // PWM mode 1 en CH1
  TIM2->CCER  = TIM_CCER_CC1E;
  TIM2->CR1   = TIM_CR1_CEN;
}

static void tim22_init_keypad_scan(void)
{
  RCC->APB2ENR |= RCC_APB2ENR_TIM22EN;
  /* 5 ms → con 16 MHz: prescaler para 1 kHz y ARR=5? Mejor directo 1 kHz */
  TIM22->PSC = 16000 - 1;  // 1 kHz
  TIM22->ARR = KEYPAD_SCAN_MS - 1; // 5 ms -> conteo 5
  TIM22->DIER = TIM_DIER_UIE;
  TIM22->CR1  = TIM_CR1_CEN;
  NVIC_EnableIRQ(TIM22_IRQn);
}

static void buzz_timer_init(void)
{
  RCC->APB2ENR |= RCC_APB2ENR_TIM21EN;
  uint32_t pclk = 16000000;
  uint32_t toggles = BUZZ_TONE_HZ * 2; // para onda cuadrada
  uint32_t arr = (pclk / toggles) - 1;
  TIM21->PSC = 0;
  TIM21->ARR = arr;
  TIM21->CCR2 = (arr+1)/2;
  TIM21->CCMR1 &= ~(0xFF00);
  TIM21->CCMR1 |= (6u<<12); // PWM1 CH2
  TIM21->CCER  &= ~TIM_CCER_CC2E; // apagado al inicio
  TIM21->CR1    = TIM_CR1_CEN;
}

static void buzz_start(void)
{
  TIM21->CCER |= TIM_CCER_CC2E;
}
static void buzz_stop(void)
{
  TIM21->CCER &= ~TIM_CCER_CC2E;
}

static void buzz_schedule_2(void)
{
  buzz_beeps_left = 2;
  buzz_phase_ms = 0;
  buzz_on = false;           // empezará con OFF→ON
}

/* ===================== Helpers ===================== */
static void set_leds(bool r, bool y, bool b)
{
  if (r) LED_PORT->ODR |= LED_R_PIN; else LED_PORT->ODR &= ~LED_R_PIN;
  if (y) LED_PORT->ODR |= LED_Y_PIN; else LED_PORT->ODR &= ~LED_Y_PIN;
  if (b) LED_PORT->ODR |= LED_B_PIN; else LED_PORT->ODR &= ~LED_B_PIN;
}

static void motor_set_duty(uint16_t duty_0_1000)
{
  if (duty_0_1000 > 1000) duty_0_1000 = 1000;
  TIM2->CCR1 = ((TIM2->ARR+1) * duty_0_1000) / 1000;
}

/* Keypad low-level */
static void keypad_drive_row(uint8_t r)
{
  // Inactivas en alto, activamos fila r a 0
  uint32_t out = KP_R0_PIN|KP_R1_PIN|KP_R2_PIN|KP_R3_PIN;
  KP_R_PORT->ODR |= out; // alto
  switch(r) {
    case 0: KP_R_PORT->ODR &= ~KP_R0_PIN; break;
    case 1: KP_R_PORT->ODR &= ~KP_R1_PIN; break;
    case 2: KP_R_PORT->ODR &= ~KP_R2_PIN; break;
    case 3: KP_R_PORT->ODR &= ~KP_R3_PIN; break;
  }
}
static uint8_t keypad_read_cols(void)
{
  uint8_t c0 = (KP_C_PORT->IDR & KP_C0_PIN) ? 1:0;
  uint8_t c1 = (KP_C_PORT->IDR & KP_C1_PIN) ? 1:0;
  uint8_t c2 = (KP_C_PORT->IDR & KP_C2_PIN) ? 1:0;
  uint8_t c3 = (KP_C_PORT->IDR & KP_C3_PIN) ? 1:0;
  return (uint8_t)( (c0<<0)|(c1<<1)|(c2<<2)|(c3<<3) );
}

/* FSM helpers */
static void start_bebida(uint8_t b)
{
  switch(b) {
    case 1: t_total_ms = T_CAPUCHINO_MS; break;
    case 2: t_total_ms = T_EXPRESSO_MS; break;
    case 3: t_total_ms = T_LATE_MS; break;
    case 4: t_total_ms = T_AMERICANO_MS; break;
    default: t_total_ms = 0; break;
  }
  t_phase_ms = t_total_ms / 3;
  t_rem_ms = t_total_ms;
  t_phase_rem_ms = t_phase_ms;
  phase = PH1;
  apply_phase_outputs();
}

static void apply_phase_outputs(void)
{
  switch(phase) {
    case PH1: // Iniciando
      set_leds(true,false,false);
      motor_set_duty(DUTY_OFF);
      lcd_clear();
      lcd_goto(0,0); lcd_puts("Iniciando");
      break;
    case PH2: // Preparando
      set_leds(false,true,false);
      motor_set_duty(DUTY_MEDIO);
      lcd_clear();
      lcd_goto(0,0); lcd_puts("Preparando");
      break;
    case PH3: // sirviendo
      set_leds(false,false,true);
      motor_set_duty(DUTY_ALTO);
      lcd_clear();
      lcd_goto(0,0); lcd_puts("sirviendo");
      break;
  }
  ui_show_time_remaining();
}

/* ===================== UI / LCD ===================== */
static void ui_refresh(void)
{
  if (app == APP_IDLE) {
    /* Scroll de "Selecciona una opcion" en fila 1 */
    char temp[32];
    const char* src = idle_text;
    uint32_t n = 0;
    // construir ventana circular de 16 desde scroll_idx
    for (int i=0;i<16;i++) {
      temp[i] = src[(scroll_idx + i) %  (int)strlen(src)];
    }
    temp[16]=0;
    lcd_clear();
    lcd_goto(0,0); lcd_puts(temp);
    lcd_goto(1,0); lcd_puts("A=Menu * Inicia");
  }
  else if (app == APP_MENU) {
    /* Scroll de opciones */
    char temp[32];
    const char* src = menu_text;
    for (int i=0;i<16;i++) temp[i] = src[(scroll_idx + i) % (int)strlen(src)];
    temp[16]=0;

    lcd_clear();
    lcd_goto(0,0); lcd_puts(temp);
    lcd_goto(1,0);
    if (bebida>=1 && bebida<=4) {
      static const char* names[5] = {"","Capuchino","Expresso","Late","Americano"};
      char buf[17];
      // tamaño textual
      const char* sz = (size_sel==1)?"P":(size_sel==3)?"G":"M";
      if (bebida_ok) {
        // Confirmado
        snprintf(buf, sizeof(buf), "%u=%s C:OK %s", bebida, names[bebida], sz);
      } else {
        snprintf(buf, sizeof(buf), "%u=%s C:Guardar %s", bebida, names[bebida], sz);
      }
      lcd_puts_len(buf,16);
    } else {
      lcd_puts("Num+C; B=Tam; *=Go");
    }
  }
  else if (app == APP_SIZE) {
    lcd_clear();
    lcd_goto(0,0); lcd_puts("Tam:1=P 2=M 3=G");
    lcd_goto(1,0); lcd_puts("C=Guardar  D=Borra");
  }
  else if (app == APP_RUN) {
    // La línea 0 ya se setea en apply_phase_outputs()
    ui_show_time_remaining();
  }
  else if (app == APP_PAUSE) {
    // ya mostrado "Pausa"
    // nada
  }
  else if (app == APP_DONE) {
    // ya mostrado "Disfrutalo"
  }
}

static void ui_show_time_remaining(void)
{
  lcd_goto(1,0);
  uint32_t sec = (t_rem_ms+999)/1000;
  char buf[17];
  snprintf(buf,sizeof(buf),"Restante: %3lus", (unsigned long)sec);
  lcd_puts_len(buf,16);
}

/* ===================== LCD (I2C + PCF8574) ===================== */

static void i2c1_write_byte(uint8_t addr7, uint8_t data)
{
  // START + send byte
  I2C1->CR2 = (addr7<<1) | (1u<<16) | I2C_CR2_START | I2C_CR2_AUTOEND;
  while(!(I2C1->ISR & I2C_ISR_TXIS));
  I2C1->TXDR = data;
  while(!(I2C1->ISR & I2C_ISR_STOPF));
  I2C1->ICR = I2C_ICR_STOPCF;
}

static void lcd_pulse(uint8_t d)
{
  i2c1_write_byte(LCD_I2C_ADDR_7B, d | LCD_EN | LCD_BL);
  i2c1_write_byte(LCD_I2C_ADDR_7B, d | LCD_BL);
}

static void lcd_write_nibble(uint8_t en_rs_bl, uint8_t nib)
{
  uint8_t d = en_rs_bl | ((nib & 0x0F) << 0);
  lcd_pulse(d);
}

static void lcd_cmd(uint8_t c)
{
  uint8_t rs = 0; // comando
  lcd_write_nibble(rs, (c>>4)&0x0F);
  lcd_write_nibble(rs, c & 0x0F);
}

static void lcd_data(uint8_t d8)
{
  uint8_t rs = LCD_RS;
  lcd_write_nibble(rs, (d8>>4)&0x0F);
  lcd_write_nibble(rs, d8 & 0x0F);
}

static void lcd_init(void)
{
  /* Secuencia 4-bit */
  for (volatile int i=0;i<8000;i++); // ~ms de margen (no delay activo de runtime crítico)
  lcd_write_nibble(0, 0x03); for (volatile int i=0;i<2000;i++);
  lcd_write_nibble(0, 0x03); for (volatile int i=0;i<2000;i++);
  lcd_write_nibble(0, 0x03); for (volatile int i=0;i<2000;i++);
  lcd_write_nibble(0, 0x02); // 4-bit

  lcd_cmd(0x28); // 2 líneas, 5x8
  lcd_cmd(0x08); // display off
  lcd_cmd(0x01); // clear
  for (volatile int i=0;i<3000;i++);
  lcd_cmd(0x06); // entry mode
  lcd_cmd(0x0C); // display on, cursor off
}

static void lcd_clear(void) { lcd_cmd(0x01); for(volatile int i=0;i<3000;i++); }
static void lcd_goto(uint8_t row, uint8_t col)
{
  uint8_t addr = (row==0)? (0x00+col) : (0x40+col);
  lcd_cmd(0x80 | addr);
}
static void lcd_puts(const char *s) { while(*s) lcd_data((uint8_t)*s++); }
static void lcd_puts_len(const char* s, uint8_t len)
{
  for(uint8_t i=0;i<len;i++){
    char c = s[i];
    if (!c) { lcd_data(' '); }
    else lcd_data((uint8_t)c);
  }
}
